<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Leetcode刷题之路——232. 用栈实现队列</title>
    <link href="/2021/03/05/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2021/03/05/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（ <code>push</code> 、 <code>pop</code> 、 <code>peek</code> 、 <code>empty</code> ）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li> <code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li> <code>int pop()</code> 从队列的开头移除并返回元素</li><li> <code>int peek()</code> 返回队列开头的元素</li><li> <code>bool empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code> </li></ul><p>说明：</p><ul><li>你只能使用标准的栈操作 —— 也就是只有 <code>push to top</code> , <code>peek/pop from top</code> , <code>size</code> , 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p>进阶：</p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><p>示例：</p><pre><code class="hljs gradle">输入：[<span class="hljs-string">&quot;MyQueue&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;peek&quot;</span>, <span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-string">&quot;empty&quot;</span>][[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [], []]输出：[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">false</span>]解释：MyQueue myQueue = <span class="hljs-keyword">new</span> MyQueue();myQueue.<span class="hljs-keyword">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// queue is: [1]</span>myQueue.<span class="hljs-keyword">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// queue is: [1, 2] (leftmost is front of the queue)</span>myQueue.peek(); <span class="hljs-comment">// return 1</span>myQueue.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// return 1, queue is [2]</span>myQueue.empty(); <span class="hljs-comment">// return false</span></code></pre><p>提示：</p><ul><li> <code>1 &lt;= x &lt;= 9</code> </li><li>最多调用 <code>100</code> 次 <code>push</code> 、 <code>pop</code> 、 <code>peek</code> 和 <code>empty</code> </li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>没啥好分析的，就是C++的栈 <code>stack</code> 还没有用过，需要学习一下。</p><p>具体代码如下：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">stack</span> &lt;<span class="hljs-keyword">int</span>&gt; instack, outstack;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">in2out</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span>(!instack.empty()) &#123;            outstack.push(instack.top());            instack.pop();        &#125;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">/** Initialize your data structure here. */</span>    MyQueue() &#123;    &#125;        <span class="hljs-comment">/** Push element x to the back of queue. */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        instack.push(x);    &#125;        <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(outstack.empty()) &#123;            in2out();        &#125;        <span class="hljs-keyword">int</span> number = outstack.top();        outstack.pop();        <span class="hljs-keyword">return</span> number;    &#125;        <span class="hljs-comment">/** Get the front element. */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(outstack.empty()) &#123;            in2out();        &#125;        <span class="hljs-keyword">int</span> number = outstack.top();        <span class="hljs-keyword">return</span> number;    &#125;        <span class="hljs-comment">/** Returns whether the queue is empty. */</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> instack.empty() &amp;&amp; outstack.empty();    &#125;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><span class="hljs-comment"> * MyQueue* obj = new MyQueue();</span><span class="hljs-comment"> * obj-&gt;push(x);</span><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><span class="hljs-comment"> * int param_3 = obj-&gt;peek();</span><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><span class="hljs-comment"> */</span></code></pre><h1 id="一些细节的总结"><a href="#一些细节的总结" class="headerlink" title="一些细节的总结"></a>一些细节的总结</h1><ul><li>C++的STL还是需要都看一下，免得要用的时候不知道</li><li>当只有一个线程对栈进行读写操作的时候，总有一个栈是空的。在多线程应用中，如果我们只有一个队列，为了线程安全，我们在读或者写队列的时候都需要锁住整个队列。而在两个栈的实现中，只要写入栈不为空，那么push操作的锁就不会影响到pop。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题之路——354. 俄罗斯套娃信封问题</title>
    <link href="/2021/03/04/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94354.%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/04/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94354.%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 <code>(w, h)</code> 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p>说明:<br>不允许旋转信封。</p><p>示例:</p><pre><code class="hljs inform7">输入: envelopes = <span class="hljs-comment">[<span class="hljs-comment">[5,4]</span>,<span class="hljs-comment">[6,4]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[2,3]</span>]</span>输出: 3 解释: 最多信封的个数为 3, 组合为: <span class="hljs-comment">[2,3]</span> =&gt; <span class="hljs-comment">[5,4]</span> =&gt; <span class="hljs-comment">[6,7]</span>。</code></pre><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><h2 id="个人初尝试"><a href="#个人初尝试" class="headerlink" title="个人初尝试"></a>个人初尝试</h2><p>最开始的思路是采用滑窗，将一个信封的设定为窗口的下限和上限，再遍历所有的信封，当有符合上下限变动条件，即可以被装下或者装下别的信封时，更新上下限，并计数+1。如此对每一个信封进行这样的操作，就可以得到最大的信封数了。</p><p>具体代码如下：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(envelopes.size() != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> size = envelopes.size();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++) &#123;                <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; minenv = envelopes[j];                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; maxenv = envelopes[j];                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;                    <span class="hljs-keyword">if</span>(envelopes[i][<span class="hljs-number">0</span>] &gt; maxenv[<span class="hljs-number">0</span>] &amp;&amp; envelopes[i][<span class="hljs-number">1</span>] &gt; maxenv[<span class="hljs-number">1</span>]) &#123;                        maxenv = envelopes[i];                        ++tmp;                    &#125;                    <span class="hljs-keyword">if</span>(envelopes[i][<span class="hljs-number">0</span>] &lt; minenv[<span class="hljs-number">0</span>] &amp;&amp; envelopes[i][<span class="hljs-number">1</span>] &lt; minenv[<span class="hljs-number">1</span>]) &#123;                        minenv = envelopes[i];                        ++tmp;                    &#125;                &#125;                <span class="hljs-keyword">if</span>(tmp &gt; max) &#123;                    max = tmp;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;;</code></pre><p>但这个算法并不能成功，有一个明显的问题开始时没有想到。那就是当在最开始的时候就碰到了最小的或者最大的信封，即使后面遍历到了可以装下去的，也不会再计数了。。。。。。一时半会没有想到好的解决方案，看题解！</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>按照题解的思路，这个题目本质是要找到最长严格递增子序列，二维的不好同时考虑，就控制一维，再处理另外一维。为了避免在前一维相同的情况下，导致第二维最长子序列求出来不符合要求，所以在排序的时候可以将第一维升序，第二维降序排列，避免出现例外情况。具体可参考 <a href="https://leetcode-cn.com/problems/russian-doll-envelopes/solution/e-luo-si-tao-wa-xin-feng-wen-ti-by-leetc-wj68/">官方题解</a></p><p>具体代码如下</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;        <span class="hljs-keyword">if</span>(envelopes.size() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> size = envelopes.size();                sort(envelopes.begin(), envelopes.end(), [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; b) &#123;        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) &#123;            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &gt; b[<span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];        &#125;    &#125;);                <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">fmax</span><span class="hljs-params">(size, <span class="hljs-number">1</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; size; ++i) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;                <span class="hljs-keyword">if</span>(envelopes[j][<span class="hljs-number">1</span>] &lt; envelopes[i][<span class="hljs-number">1</span>]) &#123;                    fmax[i] = max(fmax[i], fmax[j] + <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> *max_element(fmax.begin(), fmax.end());    &#125;&#125;;</code></pre><h1 id="一些细节的总结"><a href="#一些细节的总结" class="headerlink" title="一些细节的总结"></a>一些细节的总结</h1><ul><li>sort的用法比较灵活，可以手撸自己的排序规则，并直接写在第三个参数中</li><li>C++中的 <code>&amp;</code> 指示引用，不可和C中的取地址符弄混！引用的使用用法需要进行后续总结</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题之路——338. 比特位计数</title>
    <link href="/2021/03/03/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94338.%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <url>/2021/03/03/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94338.%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非负整数 <code>num</code> 。对于 <code>0 ≤ i ≤ num</code> 范围中的每个数字 <code>i</code> ，计算其二进制数中的 <code>1</code> 的数目并将它们作为数组返回。</p><p>示例 1:</p><pre><code class="hljs makefile"><span class="hljs-section">输入: 2</span><span class="hljs-section">输出: [0,1,1]</span></code></pre><p>示例 2:</p><pre><code class="hljs makefile"><span class="hljs-section">输入: 5</span><span class="hljs-section">输出: [0,1,1,2,1,2]</span></code></pre><p>进阶:</p><ul><li>给出时间复杂度为 <code>O(n*sizeof(integer))</code> 的解答非常容易。但你可以在线性时间 <code>O(n)</code> 内用一趟扫描做到吗？</li><li>要求算法的空间复杂度为 <code>O(n)</code> 。</li><li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 <code>__builtin_popcount</code> ）来执行此操作。</li></ul><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><h2 id="个人初尝试"><a href="#个人初尝试" class="headerlink" title="个人初尝试"></a>个人初尝试</h2><p>比较直接的思路，把每一个数都计算一遍，然后存下来输出。每一个数用辗转相除法算出1的个数。</p><p>具体代码如下：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(num &gt;= <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span>(num%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;                ++count;            &#125;            num = num/<span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>) &#123;            ++count;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(num + <span class="hljs-number">1</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;=num; ++i) &#123;            result[i] = countone(i);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre><p>在第一次时出现了问题，得到的答案不对。仔细逐行分析之后发现是 <code>while</code> 中的 <code>if</code> 放到了除法后面，这就导致了取余的时候实际已经不是最开始的那个数了。调整顺序后问题解决。</p><p>虽然达成了题目的要求，但是对于进阶的要求其实并不满足，时间上仍然比较长。由于自己没有啥更好的思路了，看题解！</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="最低有效位"><a href="#最低有效位" class="headerlink" title="最低有效位"></a>最低有效位</h3><p>对于任意一个正整数 <code>x</code>  ，将其右移一位，相当于将该数的最低位去掉。如果去掉最低位的数的比特数已经知道，则原数的比特数也可以推理得到。如果原数为偶数，则比特数相同；为奇数则比特数 <code>+1</code> 。即<br>$$<br>bit[x] =<br>    \begin{cases}<br>        bit[{x \over 2}],  &amp; \text{如果 $x$ 是偶数} \<br>        bit[{x \over 2}] + 1, &amp; \text{如果 $x$ 是奇数} \<br>    \end{cases}<br>$$<br>按照这个思路，从0开始遍历即可得到所需的bit值。其中奇数偶数的判断可以化简为对2取模。</p><p>具体代码如下</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(num + <span class="hljs-number">1</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;=num; ++i) &#123;            result[i] = result[i &gt;&gt; <span class="hljs-number">1</span>] + i%<span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre><h1 id="一些细节的总结"><a href="#一些细节的总结" class="headerlink" title="一些细节的总结"></a>一些细节的总结</h1><ul><li>注意代码运行的逻辑顺序！</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题之路——304.二维区域和检索 - 矩阵不可变</title>
    <link href="/2021/03/02/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94304.%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <url>/2021/03/02/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94304.%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 <code>(row1, col1)</code> ，右下角为 <code>(row2, col2)</code> 。</p><p>示例：</p><pre><code class="hljs livescript">给定 matrix = [  [<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>],  [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>],  [<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>],  [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>]]sumRegion<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>)</span> -&gt;</span> <span class="hljs-number">8</span>sumRegion<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span> -&gt;</span> <span class="hljs-number">11</span>sumRegion<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span> -&gt;</span> <span class="hljs-number">12</span></code></pre><p>提示：</p><ul><li>你可以假设矩阵不可变。</li><li>会多次调用 <code>sumRegion</code> 方法。</li><li>你可以假设 <code>row1 ≤ row2</code> 且 <code>col1 ≤ col2</code> 。</li></ul><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><h2 id="个人初尝试"><a href="#个人初尝试" class="headerlink" title="个人初尝试"></a>个人初尝试</h2><p>这个题目实际就是昨天的前缀和的二维形式，有了一个思路就是把它看作多个一维的前缀和，用一个二维的 <code>sum</code> 存储每一行的前缀和，按照输入把每行通过前缀和求出来再加到一起就得到了一个方形区域内的总和了。</p><p>具体代码如下</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumMatrix</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; sum;    NumMatrix(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix) &#123;        <span class="hljs-keyword">if</span>(matrix.size() != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> rowlen = matrix[<span class="hljs-number">0</span>].size();            <span class="hljs-keyword">int</span> columnlen = matrix.size();            sum.resize(columnlen);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; columnlen; i++) &#123;                sum[i].resize(rowlen + <span class="hljs-number">1</span>);                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; rowlen; j++) &#123;                    sum[i][j + <span class="hljs-number">1</span>] = sum[i][j] + matrix[i][j];                &#125;            &#125;         &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row1, <span class="hljs-keyword">int</span> col1, <span class="hljs-keyword">int</span> row2, <span class="hljs-keyword">int</span> col2)</span> </span>&#123;        <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row1; i &lt;= row2; i++)　&#123;            total += sum[i][col2 + <span class="hljs-number">1</span>] - sum[i][col1];        &#125;        <span class="hljs-keyword">return</span> total;    &#125;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><span class="hljs-comment"> * NumMatrix* obj = new NumMatrix(matrix);</span><span class="hljs-comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span><span class="hljs-comment"> */</span></code></pre><p>测试用例第一个就是输入为空，结果第一次就挂了。。。。。。所以后来加了一个判断输入不为空。</p><p>第二次通过了，但是时间上不是特别理想。于是进一步思考怎么调优。</p><h2 id="进一步的优化"><a href="#进一步的优化" class="headerlink" title="进一步的优化"></a>进一步的优化</h2><p>先前的思路是直接转化为多个一维的前缀和解决，那能不能直接用二维的前缀和呢？用一个二维的 <code>sum</code> 存储从 <code>(0, 0)</code> 到 <code>(i, j)</code> 的大小，这样在最后求和时又可以得到像一维前缀和一样 <code>O(1)</code> 的复杂度的查询算法。</p><p>具体代码如下</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumMatrix</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; sum;    NumMatrix(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix) &#123;        <span class="hljs-keyword">if</span>(matrix.size() != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> rowlen = matrix[<span class="hljs-number">0</span>].size();            <span class="hljs-keyword">int</span> columnlen = matrix.size();            sum.resize(columnlen + <span class="hljs-number">1</span>);            sum[<span class="hljs-number">0</span>].resize(rowlen + <span class="hljs-number">1</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; columnlen; i++) &#123;                sum[i + <span class="hljs-number">1</span>].resize(rowlen + <span class="hljs-number">1</span>);                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; rowlen; j++) &#123;                    sum[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = sum[i][j + <span class="hljs-number">1</span>] + sum[i + <span class="hljs-number">1</span>][j] - sum[i][j] + matrix[i][j];                &#125;            &#125;         &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row1, <span class="hljs-keyword">int</span> col1, <span class="hljs-keyword">int</span> row2, <span class="hljs-keyword">int</span> col2)</span> </span>&#123;        <span class="hljs-keyword">int</span> total = sum[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] - sum[row1][col2 + <span class="hljs-number">1</span>] - sum[row2 + <span class="hljs-number">1</span>][col1] + sum[row1][col1];        <span class="hljs-keyword">return</span> total;    &#125;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><span class="hljs-comment"> * NumMatrix* obj = new NumMatrix(matrix);</span><span class="hljs-comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span><span class="hljs-comment"> */</span></code></pre><p>这个二维的前缀和就要注意在计算时的范围， <code>+1</code> 、 <code>-1</code> 已经要仔细分析。</p><h1 id="一些细节的总结"><a href="#一些细节的总结" class="headerlink" title="一些细节的总结"></a>一些细节的总结</h1><ul><li>边界条件注意判断是否为空</li><li>二位前缀和的计算范围要仔细判断</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题之路——303.区域和检索 - 数组不可变</title>
    <link href="/2021/03/01/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94303.%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <url>/2021/03/01/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94303.%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组  <code>nums</code> ，求出数组从索引 <code>i</code> 到 <code>j</code>（ <code>i ≤ j</code> ）范围内元素的总和，包含 <code>i</code> 、 <code>j</code> 两点。</p><p>实现 <code>NumArray</code> 类：</p><ul><li> <code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li> <code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 从索引 <code>i</code> 到 <code>j</code>（ <code>i ≤ j</code> ）范围内元素的总和，包含  <code>i</code> 、 <code>j</code> 两点（也就是 <code>sum(nums[i], nums[i + 1], ... , nums[j])</code> ）</li></ul><p>示例：</p><pre><code class="hljs subunit">输入：[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;][[[<span class="hljs-string">-2</span>, 0, 3, <span class="hljs-string">-5</span>, 2, <span class="hljs-string">-1</span>]], [0, 2], [2, 5], [0, 5]]输出：[null, 1, <span class="hljs-string">-1</span>, <span class="hljs-string">-3</span>]解释：NumArray numArray = new NumArray([<span class="hljs-string">-2</span>, 0, 3, <span class="hljs-string">-5</span>, 2, <span class="hljs-string">-1</span>]);numArray.sumRange(0, 2); // return 1 ((<span class="hljs-string">-2</span>) + 0 + 3)numArray.sumRange(2, 5); // return <span class="hljs-string">-1</span> (3 + (<span class="hljs-string">-5</span>) + 2 + (<span class="hljs-string">-1</span>)) numArray.sumRange(0, 5); // return <span class="hljs-string">-3</span> ((<span class="hljs-string">-2</span>) + 0 + 3 + (<span class="hljs-string">-5</span>) + 2 + (<span class="hljs-string">-1</span>))</code></pre><p>提示：</p><ul><li> <code>0 &lt;= nums.length &lt;= 104</code> </li><li> <code>-105 &lt;= nums[i] &lt;= 105</code> </li><li> <code>0 &lt;= i &lt;= j &lt; nums.length</code> </li><li>最多调用 <code>10^4</code> 次 <code>sumRange</code> 方法</li></ul><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><h2 id="个人初尝试"><a href="#个人初尝试" class="headerlink" title="个人初尝试"></a>个人初尝试</h2><p>这个题目比较简单，直观的想法就是把数组存下来，然后按照范围遍历一遍去加起来就可以了。当然，在加的时候想了一下，可以同时从两头加，应该可以提高一些时间，便这么做了。（虽然在建立向量和保存内容的时候犯了亿点点地基错误233）</p><p>具体代码如下</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; numarray;    NumArray(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> data: nums) &#123;            numarray.push_back(data);        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i + count &lt; j - count) &#123;            sum += numarray[i + count] + numarray[j - count];            count ++;        &#125;        <span class="hljs-keyword">if</span>(i + count == j - count) &#123;            sum += numarray[i + count];        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><span class="hljs-comment"> * NumArray* obj = new NumArray(nums);</span><span class="hljs-comment"> * int param_1 = obj-&gt;sumRange(i,j);</span><span class="hljs-comment"> */</span></code></pre><p>执行下来后可以通过，但是在速度上和内存消耗上确实是比较拉跨，思考一下怎么调优。</p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>自己思考无果，毕竟想着累加总是要遍历的嘛，怎么降复杂度呢？看了题解，原来不需要把数组拷贝下来，只需要新建一个数组，用于保存在这个下标前的总和大小，即前缀和即可。。。。。。当需要知道 <code>i~j</code> 的和时，只需要把这个前缀和数组的 <code>j+1</code> 项（前 <code>j</code> 个的和）减去 <code>i</code> 项（前 <code>i-1</code> 个的和），就可以得到了。</p><p>具体代码如下</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sums;    NumArray(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;        <span class="hljs-keyword">int</span> n = nums.size();        sums.resize(n + <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            sums[i + <span class="hljs-number">1</span>] = sums[i] + nums[i];        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">return</span> sums[j + <span class="hljs-number">1</span>] - sums[i];    &#125;&#125;;</code></pre><h1 id="一些细节的总结"><a href="#一些细节的总结" class="headerlink" title="一些细节的总结"></a>一些细节的总结</h1><ul><li>在能明确空间大小的时候，最好限定开辟结构的大小，以节省空间</li><li>平时多练练看看，好久不写连基本的用法都忘了。。。。。。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题之路——1338.数组大小减半</title>
    <link href="/2020/12/01/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%941338.%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E5%87%8F%E5%8D%8A/"/>
    <url>/2020/12/01/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%941338.%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E5%87%8F%E5%8D%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>arr</code> 。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。</p><p>返回 <strong>至少</strong> 能删除数组中的一半整数的整数集合的最小大小。</p><p>示例 1：</p><pre><code class="hljs dust"><span class="xml">输入：arr = [3,3,3,3,5,5,5,2,2,7]</span><span class="xml">输出：2</span><span class="xml">解释：选择 </span><span class="hljs-template-variable">&#123;3,7&#125;</span><span class="xml"> 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。</span><span class="xml">大小为 2 的可行集合有 </span><span class="hljs-template-variable">&#123;3,5&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;3,2&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;5,2&#125;</span><span class="xml">。</span><span class="xml">选择 </span><span class="hljs-template-variable">&#123;2,7&#125;</span><span class="xml"> 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。</span></code></pre><p>示例 2：</p><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[7,7,7,7,7,7]</span>输出：<span class="hljs-number">1</span>解释：我们只能选择集合 &#123;<span class="hljs-number">7</span>&#125;，结果数组为空。</code></pre><p>示例 3：</p><pre><code class="hljs fix"><span class="hljs-attr">输入：arr </span>=<span class="hljs-string"> [1,9]</span><span class="hljs-string">输出：1</span></code></pre><p>示例 4：</p><pre><code class="hljs yaml"><span class="hljs-string">输入：arr</span> <span class="hljs-string">=</span> [<span class="hljs-number">1000</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]<span class="hljs-string">输出：1</span></code></pre><p>示例 5：</p><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]输出：<span class="hljs-number">5</span></code></pre><p>提示：</p><ul><li> <code>1 &lt;= arr.length &lt;= 10^5</code> </li><li> <code>arr.length</code> 为偶数</li><li> <code>1 &lt;= arr[i] &lt;= 10^5</code> </li></ul><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><h2 id="个人初尝试"><a href="#个人初尝试" class="headerlink" title="个人初尝试"></a>个人初尝试</h2><p>显然，这个题目涉及到了数据的存储，我需要知道每个数字存在多少个，才能去选择删减。删减的思路也挺直接的，从最大的删减起，当删去后的数组大小小于或等于原长度的一半，当作删减完成，返回删减的元素数值。</p><p>设及存储，显然用数组来存是不大理智的，因为我们需要同时储存数字和个数。直接定义数组只能把下标当作数字，那就给排序带来了相当大的麻烦，且空间上不方便开辟。那么自然的，想到用 <code>map</code> 来存储，用一对键值对来存储数字和个数。</p><p>排序方面自然是想要用 <code>sort()</code> 进行排序，而且降序排序就足够了。但是无法对 <code>map</code> 来进行降序排序，所以在 <code>map</code> 生成后，我们还需要把生成的 <code>map</code> 中的数据转存出来。因为数字数目的不确定，而且我们的输出值不需要知道要删去哪些数字。那么，我们就用一个 <code>vector</code> 保存 <code>map</code> 中个数的那一栏就好了，然后再排序，开始进行计算。</p><p>仔细想想，不需要进行 <code>map</code> 的排序（因为按照key值排序没有意义），那么使用 <code>unordered_map</code> 似乎是一个更有助于性能提升的选择。</p><p>具体代码实现如下</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSetSize</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> cutsize = <span class="hljs-number">0</span>;                <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;umap;                <span class="hljs-comment">//循环构建map</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); ++i) &#123;            umap[arr[i]]++;        &#125;                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;numlist;        <span class="hljs-comment">//循环构建vector</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; umap.size(); ++i) &#123;            numlist.push_back(umap[i]);        &#125;        <span class="hljs-comment">//对vector进行排序</span>        sort(numlist.begin(), numlist.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());        <span class="hljs-comment">//循环开始计算</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numlist.size(); ++i) &#123;            <span class="hljs-keyword">if</span>(cutsize * <span class="hljs-number">2</span> &gt;= arr.size()) &#123;                <span class="hljs-keyword">return</span> count;            &#125;            cutsize += numlist[i];            count++;        &#125;    &#125;&#125;;</code></pre><p>第一次提交无法通过，提示我编译出错，没有 <code>return</code> 。。。。。。于是在最后一个 <code>for</code> 循环外面加了一个 <code>return count;</code> 运行通过，但是效率么。。。。。低的吓人。</p><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><p>看了看官方给出的代码，思路和我是一样的，但是性能却提高特别多。代码如下</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSetSize</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; freq;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num: arr) &#123;            ++freq[num];        &#125;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; occ;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [k, v]: freq) &#123;            occ.push_back(v);        &#125;        sort(occ.begin(), occ.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c: occ) &#123;            cnt += c;            ans += <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (cnt * <span class="hljs-number">2</span> &gt;= arr.size()) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>显然，肯定是 <code>for</code> 循环的用法带来的巨大提升。</p><p>经过测试，将原先的代码中更改为官方给出的样式，发现如下语句的更改性能提升巨大</p><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [k, v]: freq) &#123;    occ.push_back(v);&#125;</code></pre><p>式子中的 <code>&amp;</code> 可以去掉，因为这表示可以取出的 <code>[k, v]</code> 进行修改，但实际上我们不需要修改。</p><p>经分析，使用 <code>i</code> 来循环，每次都蕴藏了一个查询的过程，自然会消耗不少的资源。而利用这样的基于范围的 <code>for</code> ，就不存在这样的问题。经测试，将循环量从 <code>i</code> 替换成 <code>map</code> 的迭代器，也是同样层次的性能提升。</p><h1 id="一些细节的总结"><a href="#一些细节的总结" class="headerlink" title="一些细节的总结"></a>一些细节的总结</h1><ul><li>关于 <code>sort()</code> <ul><li> <code>#include &lt;algorithm&gt;</code> </li><li>前两个参数是范围，第三个参数是排序方法</li><li>排序方法可自定义，为 <code>bool</code> 的返回，两个输入</li><li>已定义好的排序方法（记得后面加括号）<ul><li> <code>equal_to&lt;Type&gt;</code></li><li> <code>not_equal_to&lt;Type&gt;</code></li><li> <code>greater&lt;Type&gt;</code></li><li> <code>greater_equal&lt;Type&gt;</code></li><li> <code>less&lt;Type&gt;</code></li><li> <code>less_equal&lt;Type&gt;</code></li></ul></li></ul></li><li>基于范围的 <code>for</code> 以后可以多用用</li><li>注意 <code>map</code> 中的查询，要遍历还是得依靠迭代器</li><li> <code>auto</code> 是个好东西，活用</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题之路——16.11.跳水板</title>
    <link href="/2020/11/30/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%9416.11.%E8%B7%B3%E6%B0%B4%E6%9D%BF/"/>
    <url>/2020/11/30/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%9416.11.%E8%B7%B3%E6%B0%B4%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为 <code>shorter</code> ，长度较长的木板长度为 <code>longer</code> 。你必须正好使用 <code>k</code> 块木板。编写一个方法，生成跳水板所有可能的长度。</p><p>返回的长度需要从小到大排列。</p><p><strong>示例 1</strong></p><pre><code class="hljs tap">输入：shorter = 1longer = 2k = 3输出： [3,4,5,6]解释：可以使用<span class="hljs-number"> 3 </span>次 shorter，得到结果 3；使用<span class="hljs-number"> 2 </span>次 shorter 和<span class="hljs-number"> 1 </span>次 longer，得到结果<span class="hljs-number"> 4 </span>。以此类推，得到最终结果。</code></pre><p><strong>提示：</strong></p><ul><li>0 &lt; shorter &lt;= longer</li><li>0 &lt;= k &lt;= 100000</li></ul><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><h2 id="个人初尝试"><a href="#个人初尝试" class="headerlink" title="个人初尝试"></a>个人初尝试</h2><p>简单的在纸上画一画，可以得出如下的列表</p><table><thead><tr><th align="center">shorter个数</th><th align="center">longer个数</th></tr></thead><tbody><tr><td align="center">k</td><td align="center">0</td></tr><tr><td align="center">k-1</td><td align="center">1</td></tr><tr><td align="center">k-2</td><td align="center">2</td></tr><tr><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">0</td><td align="center">k</td></tr></tbody></table><p>长度从小到大排列，就是从上表的第一行到最后一行算出来。计算公式为<br>$$<br>shorter \times 1 + longer \times 2<br>$$<br>接下来的算法实现就简单了，一个循环将所有的长度算出来即可，具体代码如下：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">divingBoard</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shorter, <span class="hljs-keyword">int</span> longer, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;lenthlist;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k+<span class="hljs-number">1</span>; ++i) &#123;            lenthlist.push_back((k-i)*shorter + i*longer);        &#125;        <span class="hljs-keyword">return</span> lenthlist;    &#125;&#125;;</code></pre><p>进行测试，发现无法通过用例，说明如下：</p><blockquote><p>输入：</p><p>1 1 0</p><p>输出：</p><p>[0]</p><p>预期结果：</p><p>[]</p></blockquote><p>阿这，我输出0和输出空不是差不多吗，醉了。。。。。。加一层 <code>k = 0</code> 不执行试试，代码如下</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">divingBoard</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shorter, <span class="hljs-keyword">int</span> longer, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;lenthlist;        <span class="hljs-keyword">if</span>(k != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k+<span class="hljs-number">1</span>; ++i) &#123;                lenthlist.push_back((k-i)*shorter + i*longer);            &#125;        &#125;        <span class="hljs-keyword">return</span> lenthlist;    &#125;&#125;;</code></pre><p>还是有一个用例过不了，说明如下：</p><blockquote><p>输入：</p><p>1 1 100000</p><p>输出：</p><p>[100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,100000,10000…</p><p>预期结果：</p><p>[100000]</p></blockquote><p>显然，这说明了上面的代码么有处理相同长度的情况，思考一下如何处理</p><p>仔细分析一下，什么时候会有相同长度呢？如果 <code>shorter</code> 和 <code>longer</code> 长度不一样的话，是绝对不会出现相同长度，要想出线相同的情况，必须是二者都相同，而且该情况下所有长度都一样。再加一层判断试试，代码如下</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">divingBoard</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shorter, <span class="hljs-keyword">int</span> longer, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;lenthlist;        <span class="hljs-keyword">if</span>(k != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span>(shorter != longer) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k+<span class="hljs-number">1</span>; ++i) &#123;                    lenthlist.push_back((k-i)*shorter + i*longer);                &#125;            &#125;            <span class="hljs-keyword">else</span> &#123;                lenthlist.push_back(k*shorter);            &#125;        &#125;        <span class="hljs-keyword">return</span> lenthlist;    &#125;&#125;;</code></pre><p>好的，这次可以通过用例了，但是效率低的可怕。。。。。。没有别的特别思路，看看大佬们咋做的</p><h2 id="一些优化方案"><a href="#一些优化方案" class="headerlink" title="一些优化方案"></a>一些优化方案</h2><h3 id="固定vector长度"><a href="#固定vector长度" class="headerlink" title="固定vector长度"></a>固定vector长度</h3><p>显然，这道题目可以看出明显的数学规律，返回的 <code>vector</code> 长度是固定的， <code>k = 0</code> 返回空， <code>shorter = longer</code> 返回长度为 <code>1</code> ，其它的返回 <code>k+1</code> 的长度。那么我们的解法中也固定好长度，既可以节省空间，直接赋值也比 <code>push_back</code> 更快一些</p><p>代码如下</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">divingBoard</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shorter, <span class="hljs-keyword">int</span> longer, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;lenthlist;            <span class="hljs-keyword">return</span> lenthlist;        &#125;        <span class="hljs-keyword">if</span>(shorter == longer) &#123;            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;lenthlist(<span class="hljs-number">1</span>);            lenthlist[<span class="hljs-number">0</span>] = k*shorter;            <span class="hljs-keyword">return</span> lenthlist;        &#125;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;lenthlist(k+<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k+<span class="hljs-number">1</span>; ++i) &#123;            lenthlist[i] = (k-i)*shorter + i*longer;        &#125;        <span class="hljs-keyword">return</span> lenthlist;    &#125;&#125;;</code></pre><p>这一次的性能提高极大！开心！</p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>递归的话我自己用的不是很多，也就没有想到这个。但是这个题目递归也挺简单，从输入后，每一次 <code>shorter - 1</code> 、 <code>longer + 1</code> 就可以了。利用 <code>sort</code> 排序， <code>unique</code> 去重。具体代码实现如下</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shorter,<span class="hljs-keyword">int</span> longer,<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span>&#123;        <span class="hljs-keyword">if</span>(m&lt;<span class="hljs-number">0</span>||n&lt;<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> t=shorter*m+longer*n;        v.push_back(t);        dg(shorter,longer,m<span class="hljs-number">-1</span>,n+<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">divingBoard</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shorter, <span class="hljs-keyword">int</span> longer, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> v;        &#125;        dg(shorter,longer,k,<span class="hljs-number">0</span>);        sort(v.begin(),v.end());        v.erase(unique(v.begin(),v.end()),v.end());        <span class="hljs-keyword">return</span> v;    &#125;&#125;;</code></pre><p>不过不得不说，递归的性能极差。。。。。。就当熟悉用法了</p><h1 id="一些细节的总结"><a href="#一些细节的总结" class="headerlink" title="一些细节的总结"></a>一些细节的总结</h1><ul><li><code>unique</code> 函数是将一组相邻重复的元素一起放到元素末尾，并返回重复区域的首地址，因此使用 <code>unique</code> 之前需要进行排序</li><li>初始化 <code>vector</code> 时不需要空格，指定长度用 <code>()</code> </li><li>要多考虑一些情况，尽可能完善</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络考试复习</title>
    <link href="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"/>
    <url>/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><ul><li>计算机网络可以视为是 <code>计算机技术</code> 和 <code>通信技术</code> 的合成</li><li>为进行网络的数据交换而建立的规则、标准或原定成为 <code>协议</code> </li><li>网络通信方式包括 <code>点到点</code> 、 <code>广播</code> 、 <code>点到多点</code> 、 <code>多点到多点</code></li><li>公用电话交换网(PSTN)中的交换设备提供 <code>电路交换</code> 方式</li><li>世界上第一个投入运行的分组交换网是 <code>ARPANET</code></li><li>ARPAnet是最早验证分组交换的网络之一</li><li>Internet起源于ARPAnet</li><li>根据计算机网络的定义，其主要特征包括 <code>支持计算机资源的共享</code> 、 <code>互联的计算机系统是自洽的系统</code> 、 <code>联网的计算机系统之间需要遵循共同的网络协议</code> <ul><li>关于计算机网络的最简单定义是：一些相互连接的、以共享资源为目的的、自治的计算机的集合</li></ul></li><li>计算机网络按照网络规模大小可以分为 <code>PAN、LAN、MAN、WAN</code><ul><li>PAN：personal area network 个人区域网络<ul><li>无线连接：蓝牙，红外，NFC</li><li>有线连接：USB电缆</li><li>常用于传输小文件、如音乐、照片、日历、约定等</li></ul></li><li>LAN：local area network 局域网<ul><li>由一组设备组成，如计算机、服务器、交换机、打印机等</li><li>最常见的局域网类型是以太网，两台或多台计算机通过电缆连接到以太网交换机上</li></ul></li><li>MAN：metropolitan area network 城域网<ul><li>这是一种比校园网区域网络还大的网络</li><li>它是一种横跨一个城市或城镇的多个建筑的网络</li><li>城域网通常使用高速连接，例如光缆</li><li>城域网是一种高速网络，能够在城市中共享数据和资源提供服务</li></ul></li><li>WAN：wide area network 广域网<ul><li>WAN是最大的网络类型，一个WAN可以包括多个LAN、CAN及MAN</li><li>是一种跨越很大地理区域的网络，例如一个国家，一个大陆，甚至整个地球，广域网的一个很好的例子就是互联网</li></ul></li></ul></li><li>网络分类方法：<code>局域网/广域网</code> 、 <code>有线网/无线网</code> 、 <code>环星网/星型网</code> </li></ul><h2 id="1-2-交换原理"><a href="#1-2-交换原理" class="headerlink" title="1.2 交换原理"></a>1.2 交换原理</h2><ul><li><p> <code>虚电路</code> 、 <code>TCP</code> 能提供面向连接的服务</p></li><li><p>现有的公共数据网主要采用的技术是 <code>分组交换</code> </p></li><li><p><code>数据报</code> 、 <code>信元交换</code> 、 <code>虚电路</code> 属于分组交换技术</p><ul><li>信元交换：信元交换又叫异步传输模式（Asynchronous Transfer Mode，ATM），是一种面向连接的快速分组交换技术，它是通过建立虚电路来进行数据传输的。</li></ul></li><li><p>电路交换、报文交换、分组交换三者的优缺点</p><ul><li>电路交换：此种方式在通信之前bai需要在通信的双方间建立成一条被双方独占的物理通道。这个通道是由双方间的交换设备和链路逐段连接而建成的<ul><li>优点：<ul><li>数据直达传输，延迟小，具有很强的实时性</li><li>双方通信是有序的，不存在失序问题</li><li>该种交换方式既可以用于传输模拟信号，也可用于传输数字信号</li></ul></li><li>缺点：<ul><li>该交换方式建立连接平均时间较长，影响效率</li><li>该交换方式对信道的利用率较低。建立的物理通路即使处于空闲状态，也会独占通路</li><li>不同类型，规格，速率的终端难以相互进行通信，且易发生差错</li></ul></li></ul></li><li>报文交换：此种方式以【报文】为数据交换的单位，报文中携带目标地址、源地址等信息，交换结点的过程中采用存储转发的传输方式<ul><li>优点：<ul><li>报文交换不存在连接建立时延，用户可以随时发送。</li><li>当某条传输路径发生故障，该交换方式可以自动重新选择另一条路径进行传输，提高了传输稳定性。</li><li>即使不同类型，规格，速率的终端也可以实现通信。</li><li>可以实现多目标发送服务。</li><li>交换方式会自动建立数据传输的优先级，提高信道的利用率。</li></ul></li><li>缺点：<ul><li>数据交换结点需要经历存储、转发这个过程，所以会引起转发时延。</li><li>此种方式只能用于数字信号。</li></ul></li></ul></li><li>分组交换：该种方式可以说是报文交换的升级版。交换仍采用存储转发传输方式，但会将一个长报文先分割为若干个较短的分组，然后再将这些分组逐个进行发送<ul><li>优点：<ul><li>该方式加速了数据的网络传输</li><li>该方式简化了存储管理，从而减少了出错机率和重发数据量</li><li>由于其分组的特点，在优先级策略传输中更具优势</li></ul></li><li>缺点：<ul><li>时延问题仍然存在，但一定程度上得到减少</li><li>采用数据报服务时，可能导致出现失序、丢失或重复分组的情况</li><li>通信效率不太高</li></ul></li></ul></li></ul></li></ul><ul><li><p>数据报服务/虚电路服务</p><ul><li>数据报方式<ul><li>为网络层提供<strong>无连接方式</strong></li><li>无连接服务<ul><li>不事先为分组的传输确定一个具体的路径，每个分组会独立的确定传输路径，不同分组传输路径可能不同</li></ul></li></ul></li><li>虚电路服务<ul><li>为网络层提供<strong>连接方式</strong></li><li>连接方式<ul><li>首先为分组的传输确定一个传输的路径，也就是要建立连接，然后沿着该连接传输系列分组，这系列分组的传输路径都是相同的</li></ul></li></ul></li></ul><table><thead><tr><th align="center"></th><th align="center">数据报服务</th><th align="center">虚电路服务</th></tr></thead><tbody><tr><td align="center"><strong>连接的建立</strong></td><td align="center">不要</td><td align="center">必须有</td></tr><tr><td align="center"><strong>目的地址</strong></td><td align="center">每个分组都有完整的目的地址</td><td align="center">仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号</td></tr><tr><td align="center"><strong>路由的选择</strong></td><td align="center">每个分组独立的进行路由选择和转发</td><td align="center">属于同一条虚电路的分组按照同一路由转发</td></tr><tr><td align="center"><strong>分组顺序</strong></td><td align="center">不保证分组有序到达</td><td align="center">保证分组的有序到达</td></tr><tr><td align="center"><strong>可靠性</strong></td><td align="center">不保证可靠通信，可靠性由用户主机保证</td><td align="center">可靠性由网络保证</td></tr><tr><td align="center"><strong>对网络故障的适应性</strong></td><td align="center">出故障的结点丢失分组，其他分组路径选择发生变化，可正常传输</td><td align="center">所有经过故障结点的虚电路均不能正常工作</td></tr><tr><td align="center"><strong>差错处理和流量控制</strong></td><td align="center">由用户主机进行流量控制，不保证数据报的可靠性</td><td align="center">可由分组交换网负责，也可由用户主机负责</td></tr></tbody></table></li><li><p>常见的网络拓扑有 <code>环形结构</code> 、 <code>总线结构</code> 、 <code>网状结构</code>  、 <code>星型结构</code> 、 <code>树形结构</code> 、 <code>混合型结构</code></p></li></ul><h2 id="1-3-网络应用需求"><a href="#1-3-网络应用需求" class="headerlink" title="1.3 网络应用需求"></a>1.3 网络应用需求</h2><ul><li>计算机网络通信的一个显著特点是 <code>间歇性、突发性</code> </li><li>如果源端发送的每一个消息均希望被目的端所接收，可以采取 <code>请求/响应</code> 的通信方式</li></ul><h2 id="1-4-网络体系架构"><a href="#1-4-网络体系架构" class="headerlink" title="1.4 网络体系架构"></a>1.4 网络体系架构</h2><ul><li><p>协议的基本要素包括 <code>语法</code> 、 <code>语义</code> 、 <code>时序</code> </p></li><li><p>我们将构成网络体系各个层次的抽象对象称作 <code>实体</code> </p></li><li><p>同一系统相邻两层的实体进行交互的地方，称为 <code>服务访问点</code> </p></li><li><p>网络体系结构是网络层次结构模型与各层协议的集合</p></li><li><p>协议与服务</p><ul><li>协议的实现保证了能够向上一层提供服务，要实现本层协议，还需要使用下面一层所提供的服务</li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务</li><li>协议是水平的，即协议是控制对等实体间通信的规则。服务是垂直的，即服务是下层向上层通过层间接口提供的</li></ul></li><li><p>关于计算机网络架构的分层</p><ul><li>每一层都实现一种相对独立的功能，降低大系统的复杂度</li><li>各层之间界面清晰，交互接口尽可能简单</li><li>下层对上层相对独立，上层调用下层提供的服务</li><li>各层的定义主要在功能方面，不应指定具体的实现方法</li></ul></li><li><p>计算机网络体系采用层次结构的主要原因</p><ul><li>使各层次的功能相对独立，使得各层次实现技术的进步不影响相邻层次，从而保持体系结构的稳定性</li><li>层次结构的方法可以简化计算机网络的实现 </li></ul></li><li><p>OSI7层网络体系</p><table><thead><tr><th align="center">OSI中的层</th><th align="center">功能</th><th align="center">TCP/IP协议族</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center">文件传输，电子邮件，文件服务，虚拟终端</td><td align="center">TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等</td></tr><tr><td align="center">表示层</td><td align="center">数据格式化，代码转换，数据加密</td><td align="center">没有协议</td></tr><tr><td align="center">会话层</td><td align="center">解除或建立与别的接点的联系</td><td align="center">没有协议</td></tr><tr><td align="center">传输层</td><td align="center">提供端对端的接口</td><td align="center">TCP，UDP</td></tr><tr><td align="center">网络层</td><td align="center">为数据包选择路由</td><td align="center">IP，ICMP，OSPF，EIGRP，IGMP</td></tr><tr><td align="center">数据链路层</td><td align="center">传输有地址的帧以及错误检测功能</td><td align="center">SLIP，CSLIP，PPP，MTU</td></tr><tr><td align="center">物理层</td><td align="center">以二进制数据形式在物理媒体上传输数据</td><td align="center">ISO2110，IEEE802，IEEE802.2</td></tr></tbody></table><ul><li><p><strong>物理层Physical(以二进制数据形式在物理媒体上传输数据)</strong></p><p>透明的传输原始比特流</p><p>主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流(就是由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换)。这一层的数据叫做比特。</p></li><li><p><strong>数据链路层Data Link(传输有地址的帧以及错误检测功能 )</strong></p><p>数据被分割成帧</p><p>控制相邻两个结点间通信流量</p><p>把原始比特流封装在分离的单元里，并且利用协议交换这些单元</p><p>定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。</p></li><li><p><strong>网络层Network(为数据包选择路由)</strong></p><p>即路由器，交换机那些具有寻址功能的设备所实现的功能。这一层定义的是IP地址，通过IP地址寻址。所以产生了IP协议。</p></li><li><p><strong>传输层Transport(提供端对端的接口协议，TCP/OCP等)</strong></p><p>自下而上第一个提供端到端服务</p><p>提供建立、维护和拆除端到端连接功能</p></li><li><p><strong>会话层Session(解除与建立与别的接口的联系)</strong></p><p>会话层的作用就是建立和管理应用程序之间的通信。</p></li><li><p><strong>表示层Presentation(数据格式化，代码转换，数据加密)</strong></p><p>需要表示层（presentation），帮我们解决不同系统之间的通信语法问题</p></li><li><p><strong>应用层Application(文件传输，电子邮件，文件服务，虚拟终端)</strong></p><p>传输的数据根据应用层的协议进行服务 </p></li><li><p>记忆口诀</p><ul><li><p><strong>A</strong>ll <strong>P</strong>eople <strong>S</strong>eem <strong>T</strong>o <strong>N</strong>eed <strong>D</strong>ata <strong>P</strong>rocessing</p></li><li><p><strong>P</strong>lease <strong>D</strong>o <strong>N</strong>ot <strong>T</strong>ell <strong>S</strong>tupid <strong>P</strong>eople <strong>A</strong>nything</p></li><li><p><strong>P</strong>lease <strong>D</strong>o <strong>N</strong>ot <strong>T</strong>ake <strong>S</strong>ales <strong>P</strong>eople’s <strong>A</strong>dvice</p></li></ul></li></ul></li><li><p>在 OSI 参考模型中，第 N 层是第 N+1 层的服务提供者</p></li><li><p>在分层网络模型中，第 N 层提供的服务是 <code>利用 N-1 层提供的服务以及按 N 层协议</code> 与对等层实体交换信息来实现的</p></li><li><p>协议是指在 <code>不同节点的对等实体</code> 之间进行通信的规则或者约定</p></li><li><p>TCP/IP网络架构</p><table><thead><tr><th align="center">OSI七层网络模型</th><th align="center">TCP/IP四层概念模型</th><th align="center">对应网络协议</th></tr></thead><tbody><tr><td align="center">应用层（Application）</td><td align="center">应用层</td><td align="center">HTTP、TFTP, FTP, NFS, WAIS、SMTP</td></tr><tr><td align="center">表示层（Presentation）</td><td align="center">~</td><td align="center">Telnet, Rlogin, SNMP, Gopher</td></tr><tr><td align="center">会话层（Session）</td><td align="center">~</td><td align="center">SMTP, DNS</td></tr><tr><td align="center">传输层（Transport）</td><td align="center">传输层</td><td align="center">TCP, UDP</td></tr><tr><td align="center">网络层（Network）</td><td align="center">IP层/网络层/网际层</td><td align="center">IP, ICMP, ARP, RARP, AKP, UUCP</td></tr><tr><td align="center">数据链路层（Data Link）</td><td align="center">网络接入层</td><td align="center">FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</td></tr><tr><td align="center">物理层（Physical）</td><td align="center">~</td><td align="center">IEEE 802.1A, IEEE 802.2到IEEE 802.11</td></tr></tbody></table><ul><li><p> 应用层</p></li><li><p>传输层</p><ul><li>进程与进程之间的消息传输, 两个主要<br>的协议</li><li>TCP (Transmission Control Protocol)</li><li>UDP (User Datagram Protocol) </li></ul></li><li><p>IP层/网络层</p><ul><li> 主机到主机的数据分组传输</li><li> 唯一协议: IP</li></ul></li><li><p>网络接入层</p><ul><li>没有指定该层的实际细节</li><li>可以是任意一种底层网络</li></ul></li></ul></li><li><p>TCP/IP协议族的网络层提供的是 <code>无连接不可靠的数据报服务</code></p></li><li><p>TCP协议是面向连接的协议</p></li><li><p>物理层、数据链路层、网络层传送的数据单位分别为： <code>比特</code> 、 <code>帧</code> 、 <code>分组</code>  </p></li><li><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0.assets/image-20201128164426892.png"></p></li></ul><h2 id="1-5-网络性能评估"><a href="#1-5-网络性能评估" class="headerlink" title="1.5 网络性能评估"></a>1.5 网络性能评估</h2><ul><li>发送数据时，数据块从节点进入到传输媒体所需要的时间为 <code>数据块长度与链路带宽之比</code> </li><li> <code>吞吐量</code> 表示一段特定的时间内网络所能传送的比特数</li><li>关于带宽的描述<ul><li>链路的带宽是指链路上每秒所能传送的比特数，它取决于链路时钟和信道编码</li><li>链路的带宽往往大于链路的吞吐量</li><li>在单位时间内通过网络中某一点的最高数据率，常用的单位为bps</li></ul></li><li>关于链路吞吐量的描述<ul><li>收各种低效率因素的影响，由带宽为10Mbps的链路连接的一对节点可能值达到2Mbps的吞吐量</li><li>链路吞吐量为单位时间内成功地传送数据的数量</li><li>一段链路由两端节点以及节点之间的通信线路组成，链路吞吐量取值为3者的最小值</li></ul></li><li>关于网络设备（如交换机）的吞吐量的描述<ul><li>在单位时间内，网络设备各端口存储转发的比特数之和</li><li>吞吐量的大小主要由网络设备的输入输出端口硬件，以及程序算法的效率决定</li><li>没有帧丢失时，设备能够接收并转发的最大数据速率</li></ul></li><li>分组从网络的一端传送到另一端所需的时间叫时延，网络中时延主要组成部分包括<ul><li>发送时延<ul><li>发送时延是主机或路由器发送数据帧所需要的时间， 也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需要的时间</li><li>发送时延 = 数据帧长度（bit）/ 发送速率（bit/s）</li></ul></li><li>传播时延<ul><li>传播时延是电磁波在信道中传播一定的距离需要花费的时间</li><li>传播时延 = 信道长度（m）/ 电磁波在信道上的传播速率（m/s）</li></ul></li><li>处理时延<ul><li>主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等，这就产生了处理时延</li></ul></li><li>排队时延<ul><li>分组通过网络传输时，要经过很多路由器。分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中 排队等待转发。这两个因素就造成了排队时延 。</li></ul></li></ul></li><li>计算机网络最主要的性能指标是 <code>带宽</code> 、 <code>时延</code> </li></ul><h1 id="2-直连网络"><a href="#2-直连网络" class="headerlink" title="2.直连网络"></a>2.直连网络</h1><h2 id="2-1-物理层基本通信"><a href="#2-1-物理层基本通信" class="headerlink" title="2.1 物理层基本通信"></a>2.1 物理层基本通信</h2><ul><li><p>计算机网络物理层特性</p><ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>规程特性</li></ul></li><li><p>信息传输速率的单位是 <code>比特/秒</code></p></li><li><p>码元传输速率的单位是 <code>波特</code> </p></li><li><p>承载信息量的基本信号单位是 <code>码元</code> </p></li><li><p>通信系统必须具备的三个基本要素是 <code>信源</code> 、 <code>通信媒体</code> 、 <code>信宿</code> </p></li><li><p>调制速率，即每秒钟载波调制状态改变的数值，其单位是 1/s（称为波特，Baud）</p></li><li><p>调制速率又称为波特率，即码元传输的速率</p></li><li><p>数据传输速率，即每秒钟传输的二进制比特数，单位 bit/sec，又称为比特率</p></li><li><p>在两台设备之间实现通信，必须具备 <code>网卡</code> 、 <code>传输介质</code> 、 <code>协议</code> </p></li><li><p>网络适配器的主要功能包括 <code>实现数据链路层协议</code> 、 <code>进行串行/并行转换</code> 、 <code>缓存数据</code> </p></li><li><p>链路层的数据封装与解封是由 <code>网卡</code> 完成的</p></li><li><p>常见通信方式</p><ul><li><p>单工通信（Simplex Communication）</p><p>是指消息只能单方向传输的工作方式</p><p>在单工通信中，通信的信道是单向的，发送端与接收端也是固定的，即发送端只能发送信息，不能接收信息；接收端只能接收信息，不能发送信息。基于这种情况，数据信号从一端传送到另外一端，信号流是单方向的</p></li><li><p>半双工通信（Half-duplex Communication）</p><p>可以实现双向的通信，但不能在两个方向上同时进行，必须轮流交替地进行</p><p>在这种工作方式下，发送端可以转变为接收端；相应地，接收端也可以转变为发送端。但是在同一个时刻，信息只能在一个方向上传输。因此，也可以将半双工通信理解为一种切换方向的单工通信</p></li><li><p>全双工通信（Full duplex Communication）</p><p>是指在通信的任意时刻，线路上存在A到B和B到A的双向信号传输。 全双工通信允许数据同时在两个方向上传输，又称为双向同时通信，即通信的双方可以同时发送和接收数据。在全双工方式下，通信系统的每一端都设置了发送器和接收器，因此，能控制数据同时在两个方向上传送。全双工方式无需进行方向的切换，因此，没有切换操作所产生的时间延迟，这对那些不能有时间延误的交互式应用（例如远程监测和控制系统）十分有利。这种方式要求通讯双方均有发送器和接收器，同时，需要2根数据线传送数据信号。（可能还需要控制线和状态线，以及地线）。</p></li></ul></li></ul><h2 id="2-2-数据链路层机制"><a href="#2-2-数据链路层机制" class="headerlink" title="2.2 数据链路层机制"></a>2.2 数据链路层机制</h2><ul><li>帧定界的方法可分为 <code>字符计数法</code> 、 <code>起止标记法</code> </li><li>中继器的作用是 <code>根据输入端的信号重新生成原始信号再通过输出端传送出去</code> </li><li>奇偶校验码的特征 <code>能检查出奇数个比特错误</code> </li><li>CRC的特征 <code>能查出一定数量比特的错误</code> </li><li> <code>无确认，无连接服务</code> 是源机器向目的机器发出独立的帧，而目的机器对收到的帧不做确认</li><li>透明传输是数据链路层的基本功能，所谓透明性是指 <code>传输的数据内容、格式及编码无限制</code> </li><li>自动请求重传中差错控制的策略 <code>停止等待ARQ协议</code> 、 <code>后退N机制</code> 、 <code>选择重传机制</code> </li></ul><h2 id="2-3-可靠传输机制"><a href="#2-3-可靠传输机制" class="headerlink" title="2.3 可靠传输机制"></a>2.3 可靠传输机制</h2><ul><li><p>数据链路层实现可靠传输的基本方法包括： <code>确认</code> 、 <code>超时重传</code> 、 <code>帧序号</code> </p></li><li><p>数据链路层进行的流量控制指的是 <code>相邻节点之间</code> </p></li><li><p>两台主机之间的数据链路层采用后退 N 帧协议传输数据，数据传输速率为 16kbps，单 </p><p>向传播时延为 270ms，数据帧长度范围是 128-512 字节，接收方总是以与数据帧等长 </p><p>的帧进行确认，为使信道利用率达到最高，帧序列的比特数至少为 <code>4</code> </p><ul><li>本题即求从发送一个帧到接收到这个帧的确认为止的时间内最多可以发送多少数据帧。要尽可能多发帧，应以短的数据帧计算，首先计算出发送一帧的时间：<br>$$<br>{128 \times 8 \over 16 \times 10^3} = 64 \ ms<br>$$<br>发送一帧到收到确认为止的总时间：<br>$$<br>64 + 270 \times 2 + 64 = 668 \ ms<br>$$<br>这段时间总共可以发送<br>$$<br>{668 \over 64} = 10.4 \ 帧<br>$$<br>发送这么多帧至少需要用 <code>4</code> 位比特进行编号。</li></ul></li><li><p>接收端发现有差错时，设法通知发送端重发，直到收到正确的码字为止，这种差错控制 </p><p>方法称为 <code>自动请求重发</code> </p></li><li><p>在停止等待协议算法中，使用帧序号的目的是 <code>处理重复帧</code> </p></li></ul><h2 id="2-4-多路访问控制"><a href="#2-4-多路访问控制" class="headerlink" title="2.4 多路访问控制"></a>2.4 多路访问控制</h2><ul><li><p>解决多路访问问题的前提是 <code>寻址</code> </p></li><li><p>对于术语10base-T，base表示 <code>连接线上的信号是基带信号</code> </p><ul><li>10BASE－T是双绞线以太网，1990年由IEEE新认可的，编号为IEEE802.3i，T表示采用双绞线，现10BASE－T 采用的是非屏蔽双绞线（UTP）</li><li>技术指标<ul><li>数据传输速率 10Mbps基带传输，10表示10兆比特每秒，Base表示基带传输，T代表双绞线</li><li>每段双绞线最大有效长度 100m，采用高质量的双绞线（5类线），最大长度可到150m(HUB与工作站间及两个HUB之间)</li><li>一条通路允许最大连接HUB数 4个</li><li>拓扑结构 星形或总线形</li><li>访问控制方式 CSMA/CD</li><li>帧长度 可变，最大1518个字节</li><li>最大传输距离 100m</li><li>每个HUB可连接的工作站 96个</li></ul></li></ul></li><li><p>10 Mb/s 和 100 Mb/s 自适应系统是指 <code>端口之间 10 Mb/s 和 100 Mb/s 传输率的自动匹配功能</code> </p></li><li><p>以太网的优点是 <code>可扩充性好</code> 、 <code>成本低</code> 、 <code>施工方便</code> </p></li><li><p>以太网参考模型一般只包括物理层和数据链路层</p></li><li><p>CSMA/CD 协议的要点是： <code>碰撞检测</code> 、 <code>多点接入</code> 、 <code>载波侦听</code> </p></li><li><p>局域网采用的拓扑结构包括 <code>总线型</code> 、 <code>星型</code> </p></li><li><p>在一个采用CSMA/CD协议的网络中，传输介质是一根完整的电缆，传输速率为1Gbps，电缆中的信号传播速度是200000km/s。若最小数据帧长度减少800比特，则最远的两个站点之间的距离至少需要 <code>减少80m</code> </p><ul><li><p>设传输线路的长度是L，那么信号在电缆中传输一个来回的时间是<br>$$<br>t = {L \over 2} \times 10^{-8} \times 2 = L \times 10^{-8} \ s<br>$$<br>设最短帧长度是<br>$$<br>MIN = t \times 1 \ Gbps = 10L<br>$$<br>所以如果MIN减小了 <code>800bit</code> ，那么L就应该减少 <code>80m</code></p></li><li><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0.assets/image-20201129133333500.png"></p></li></ul></li><li><p>以太网媒体访问控制技术 CSMA/CD 的机制是 <code>争用带宽</code> </p></li><li><p>使用 CSMA/CD 协议的站点在发送帧的过程中发生冲突时，它将 <code>立即停止发送当前帧，改发冲突信号，然后进行退避处理</code>  </p></li><li><p>IEEE802 将数据链路层划分为两个子层，上子层是 <code>LLC</code> ，下子层是 <code>MAC</code> </p><ul><li>IEEE 802又称为LMSC（LAN /MAN Standards Committee， 局域网/城域网标准委员会），致力于研究局域网和城域网的物理层和MAC层中定义的服务和协议，对应OSI网络参考模型的最低两层（即物理层和数据链路层）</li><li>IEEE802系列标准把数据链路层分成LLC（Logical Link Control，逻辑链路控制）和MAC（Media Access Control，媒介接入控制）两个子层。LLC子层在IEEE802.2标准中定义，为802标准系列共用；而MAC子层协议则依赖于各自的物理层</li></ul></li><li><p>集线器的缺点是 <code>不能过滤网络流量</code> </p></li><li><p>以太网的碰撞窗口或争用期为 <code>往返时延</code> </p></li><li><p>在无线通信网中，应对隐藏终端、暴露终端问题的方法是 <code>RTS/CTS 机制</code> </p></li><li><p>截断二进制指数类型退避算法解决了 <code>站点检测到冲突后延迟发送的时间</code> </p></li><li><p>无线局域网不使用 CSMA/CD，而使用 CSMA/CA 的原因是无线局域网 <code>并非所有的站点都能听见对方</code> 、 <code>无线介质传输特征复杂，存在隐藏终端、暴露终端等问题</code> </p></li><li><p>关于无线局域网的叙述：</p><ul><li>无线局域网可分为两大类，即有固定基础设施的和无固定基础设施的</li><li>无固定基础设施的无线局域网又叫做自组织(AD HOC)网络</li><li>有固定基础设施的无线局域网，使用无线接入点（AP）作为基础设施</li></ul></li><li><p>无线局域网主要采用了 <code>预约信道</code> 方法解决数据帧的碰撞问题</p></li><li><p>关于虚拟局域网 VLAN 的叙述</p><ul><li>VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组</li><li>利用以太网交换机可以很方便地实现 VLAN</li><li>每一个 VLAN 的工作站可处在不同的局域网中</li></ul></li></ul><h1 id="3-网络互连"><a href="#3-网络互连" class="headerlink" title="3.网络互连"></a>3.网络互连</h1><h2 id="3-1-网桥与交换机"><a href="#3-1-网桥与交换机" class="headerlink" title="3.1 网桥与交换机"></a>3.1 网桥与交换机</h2><ul><li>面向无连接的 IP 协议的信息传输方式是 <code>数据报</code> </li><li>网桥实现 <code>过滤数据帧</code> 、 <code>转发数据帧</code> 、 <code>扩展LAN</code> 功能</li><li>网桥工作在 <code>数据链路层</code> </li><li>网桥可以访问同一个网络中站点的 <code>物理</code> 地址 </li><li>透明网桥是通过查找端口-地址表来决定转发路径的，而端口-地址表是 <code>网桥通过自学习算法</code> 生成的</li><li>网桥通过将帧中的 <code>目的节点的物理地址</code> 和自己地址表中的信息进行比较，实现帧的转发和过滤</li><li>交换机根据 <code>数据报</code> 、 <code>虚电路</code> 、 <code>源路由</code> 选择分组转发时的输出端口</li><li><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0.assets/image-20201129140220950.png"></li><li><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0.assets/image-20201129140235555.png"></li></ul><h2 id="3-2-网络互连与路由器"><a href="#3-2-网络互连与路由器" class="headerlink" title="3.2 网络互连与路由器"></a>3.2 网络互连与路由器</h2><ul><li><p>路由器的功能</p><ul><li>解决异构网络之间的互联问题</li><li>路由选择</li><li>分组转发</li><li>数据分段</li><li>协议转换</li><li>数据封装</li></ul></li><li><p>路由器在能够开始向输出链路传输分组的第一 bit 之前，必须先接收到整个分组，这种 </p><p>机制被称为 <code>存储转发</code></p></li><li><p>ARP 协议的作用是 <code>将 IP 地址映射到数据链路层地址</code> </p></li><li><p>路由器连接的异构网络指的是 <code>数据链路层和物理层均不同</code> </p></li><li><p>路由器涉及 Internet 体系结构的 <code>网络接口层</code> 和 <code>网络层</code> </p></li></ul><h2 id="3-3-IP服务模型与协议"><a href="#3-3-IP服务模型与协议" class="headerlink" title="3.3 IP服务模型与协议"></a>3.3 IP服务模型与协议</h2><ul><li><p>IP协议提供的服务类型是 <code>无连接的数据报服务</code> </p></li><li><p>为了防止 IP 数据包在因特网上无限制地传递，告知路由器是否应该丢弃某个数据包， </p><p>在 IP 数据包首部设置了 <code>生存时间（TTL）</code> 字段</p></li><li><p>IP层实现的功能</p><ul><li>尽力而为的不可靠传输服务</li><li>数据报的路由选择与转发</li><li>数据报的分段与重组</li></ul></li><li><p>在 MTU 较小的网络，需将数据报分成若干较小的部分进行传输，这种较小的部分叫做 <code>片</code> </p></li><li><p>分组的概念是在 <code>网络层</code> 用到的</p></li><li><p>IP数据报分片只可能发生在路由器，而重组必须在目的机</p></li><li><p>如果网络层使用数据报服务，那么需要 <code>为每个到来的分组做路由选择</code> </p></li></ul><h2 id="3-4-路由算法与协议"><a href="#3-4-路由算法与协议" class="headerlink" title="3.4 路由算法与协议"></a>3.4 路由算法与协议</h2><ul><li><p>关于RIP的描述</p><ul><li>RIP 是基于距离向量路由选择算法的</li><li>RIP 要求路由器将它关于整个 AS 的距离向量信息发布出去</li><li>RIP 要求路由器按照一定的时间间隔发布距离向量信息</li><li>RIP 要求路由器都要维护从它到每个内部路由器的距离向量</li><li>每经过一个路由器，距离值加 1</li></ul></li><li><p>OSPF 协议根据链路状态法计算最佳路由</p></li><li><p>因特网将整个网络划分为许多较小的单位，即 AS。由此，路由协议也分为两大类，即 <code>内部网关协议和外部网关协议</code> </p></li><li><p>路由选择协议</p><ul><li><p>自治系统(AS)：由同一个管理机构管理，使用统一路由策略的路由器的集合。</p><p>所以由自治系统AS可以引出两种协议： <strong>IGP</strong> 和 <strong>EGP</strong> 。IGP是负责自治系统 AS 内部通信的路由协议，而 EGP 是负责自治系统AS 间通信的路由协议</p><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0.assets/image-20201129142110896.png"></p></li><li><p>IGP</p><p><strong>IGP</strong>（Interior Gateway Protocol，内部网关协议）是在一个自治网络内网关（主机和路由器）间交换路由信息的协议。路由信息能用于网间协议（IP）或者其它网络协议来说明路由传送是如何进行的。Internet网被分成多个域或多个自治系统。一个域（domain）是一组主机和使用相同路由选择协议的路由器集合，并由单一机构管理。IGP协议包括 RIP、OSPF、IS-IS、IGRP、EIGRP（思科私有协议）等。</p><p>IGP的选路原则：</p><ul><li>优先级</li><li>开销</li><li>负载均衡</li></ul><p>典型协议：</p><ul><li><p>RIP协议</p><p><strong>RIP协议</strong>是一种内部网关协议（IGP），底层是贝尔曼福特算法，是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。RIP协议基于距离矢量算法（DistanceVectorAlgorithms），使用“跳数”(即metric)来衡量到达目标地址的路由距离。这种协议的路由器只关心自己周围的世界，只与自己相邻的路由器交换信息，范围限制在<strong>15跳</strong>(15度)之内，再远，它就不关心了。所以rip只适用于小区域。Rip协议运行在 <strong>UDP</strong> 协议之上，使用 <strong>520</strong> 端口，使用 <strong>224.0.0.9</strong> 作为组播地址，向外组播路由信息</p><p><strong>工作原理</strong>：RIP通过广播UDP报文来交换路由信息，每30秒发送一次路由信息更新。RIP提供跳跃计数(hopcount)作为尺度来衡量路由距离，跳跃计数是一个包到达目标所必须经过的路由器的数目。如果到相同目标有二个不等速或不同带宽的路由器，但跳跃计数相同，则RIP认为两个路由是等距离的。RIP最多支持的跳数为15，即在源和目的网间所要经过的最多路由器的数目为15，跳数16表示不可达。</p></li></ul><ul><li><p>OSPF协议</p><p><strong>OSPF</strong>(Open Shortest Path First开放式最短路径优先）是一个内部网关协议IGP，用于在单一自治系统内决策路由。是对链路状态路由协议的一种实现，隶属内部网关协议（IGP），故运作于自治系统内部。SPF算法用作生成最短生成树。OSPF分为OSPFv2和OSPFv3两个版本,其中OSPFv2用在IPv4网络，OSPFv3用在IPv6网络。OSPFv2是由RFC 2328定义的，OSPFv3是由RFC 5340定义的。与RIP相比，OSPF是链路状态协议，而RIP是距离矢量协议，它选择路由的度量标准是带宽，延迟。适合在大中区域，目前最流行的路由协议。Rip协议使用 <strong>224.0.0.5</strong> 作为组播地址，向外组播路由信息。DR监听 <strong>224.0.0.6</strong> 端口来获取从DOther发来的LSA信息，ospf协议号 <strong>89</strong> </p></li></ul></li><li><p>EGP</p><p><strong>EGP</strong>（Exterior Gateway Protocol，外部网关协议）是AS之间使用的路由协议,其目前只有一个协议–BGP协议</p><ul><li><p>BGP</p><p><strong>BGP</strong>(Border Gateway Protocol)边界网关协议是运行于 TCP 上的一种自治系统的路由协议。 BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议。 BGP 构建在 EGP 的经验之上。 BGP 系统的主要功能是和其他的 BGP 系统交换网络可达信息。网络可达信息包括列出的自治系统（AS）的信息。这些信息有效地构造了 AS 互联的拓朴图并由此清除了路由环路，同时在 AS 级别上可实施策略决策。</p><p>BGP属于EGP(外部网关路由协议)，可以实现自治系统间无环路的域间路由。BGP是沟通Internet广域网的主用路由协议，例如不同省份、不同国家之间的路由大多要依靠BGP协议。BGP可分为IBGP（Internal BGP）和EBGP（External BGP）。BGP的邻居关系（或称通信对端/对等实体）是通过人工配置实现的，对等实体之间通过TCP（端口179)会话交互数据。BGP路由器会周期地发送19字节的保持存活keep-alive消息来维护连接（默认周期为30秒）。在路由协议中，只有BGP使用TCP作为传输层协议</p></li></ul></li></ul></li><li><p>关于区域路由的描述</p><ul><li><p>OSPF 协议将一个自治域划分成若干区域，有一种特殊的区域叫做主干区域</p></li><li><p>域之间通过区域边界路由器互联</p></li><li><p>在自治系统中有 4 类路由器：区域内部路由器、主干路由器、区域边界路由器和自治 </p><p>域边界路由器</p></li></ul></li><li><p>关于因特网的路由选择协议的叙述</p><ul><li>RIP 是基于距离向量的路由选择协议，RIP 选择一个到目的网络具有最少路由器的路由 </li><li>OSPF 最主要特征是使用分布式链路状态协议，所有的路由器最终都能建立一个链路状态数据库</li><li>BGP 采用路径向量路由选择协议。BGP 所交换的网络可达性信息是要到达某个网络所要经过的自治系统序列 </li></ul></li><li><p>如果在一个使用链路状态路由的互连网络中有 5 个路由器和 6 个网络，那么存在 <code>5</code> 个路由表，每个表中至少有 <code>6</code> 个表项，在路由器中存在 <code>1</code> 个不同的链路状态数据库</p></li><li><p>在链路状态路由中，洪泛使链路状态的变化能够被 <code>所有路由器</code> 记录</p></li><li><p>在距离向量路由中，每个路由器从 <code>它的邻居节点</code> 接收距离向量</p></li><li><p><code>距离向量</code> 算法在设置和更新时，需要更多路由器之间的通信</p></li><li><p>BGP 协议中所交换的网络可达性信息是 <code>到达某个网络所经过的路径</code> </p></li><li><p>直接封装 RIP、OSPF、BGP 报文的协议分别为 <code>UDP</code> 、 <code>IP</code> 、 <code>TCP</code> </p></li><li><p>关于链路状态路由的描述</p><ul><li>OSPF 使用链路状态算法来实现 AS 内部路由表的更新</li><li>链路状态路由要求每个路由器使用洪泛方法向 AS 中其它路由器发送链路状态消息</li><li>链路状态的“度量”可以是距离、带宽、时延或者费用等</li></ul></li><li><p>关于BGP特征的描述</p><ul><li>BGP 的路由选择算法是基于路径向量(Path Vector)算法</li><li>BGP 路由器的路由表要包括分组到达目的网络的路径</li><li>BGP 要求相邻的 AS 边界路由器之间交换到达目的网络的路径</li></ul></li></ul><h2 id="3-5-IP地址及其划分"><a href="#3-5-IP地址及其划分" class="headerlink" title="3.5 IP地址及其划分"></a>3.5 IP地址及其划分</h2><ul><li><p>IP 地址是网际层中识别主机的 <code>逻辑地址</code> </p></li><li><p>CIDR 将 <code>网络前缀</code> 都相同的连续的 IP 地址组成“CIDR”地址块，路由表就利用 CIDR 地址块来查找目的网络</p></li><li><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0.assets/image-20201129145423820.png"></p><p>A类网络的IP地址范围为：1.0.0.1－126.255.255.254；  </p><p>B类网络的IP地址范围为：128.1.0.1－191.255.255.254；  </p><p>C类网络的IP地址范围为：192.0.1.1－223.255.255.254  </p></li><li><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0.assets/image-20201129145457731.png"></p></li><li><p>关于无分类编址 CIDR </p><ul><li>CIDR 使用各种长度的“网络前缀”来代替分类地址中的网络号和子网号</li><li>CIDR 将网络前缀都相同的连续的 IP 地址组成“CIDR”地址块</li><li>使用 CIDR，查找路由表时可能会得到多个匹配结果，应当从匹配结果中选择具有最长网络前缀的路由。因为网络前缀越长，路由就越具体 </li></ul></li><li><p>关于互联网中IP地址的叙述</p><ul><li>在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的</li><li>用网桥互连的网段仍然是一个局域网，只能有一个网络号</li><li>路由器总是具有两个或两个以上的 IP 地址</li></ul></li><li><p>RFC2373中详细定义了IPv6地址，按照定义，一个完整的IPv6地址的表示法：xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx<br> 例如：2031:0000:1F1F:0000:0000:0100:11A0:ADDF</p><p>为了简化其表示法，rfc2373提出<strong>每段中前面的0可以省略</strong> ；<strong>连续的0可省略为”::”，但只能出现一次</strong>。例如：</p><table><thead><tr><th align="center">原地址</th><th align="center">简写</th></tr></thead><tbody><tr><td align="center">1080:0:0:0:8:800:200C:417A</td><td align="center">1080::8:800:200C:417A</td></tr><tr><td align="center">FF01:0:0:0:0:0:0:101</td><td align="center">FF01::101</td></tr><tr><td align="center">0:0:0:0:0:0:0:1</td><td align="center">::1</td></tr><tr><td align="center">0:0:0:0:0:0:0:0</td><td align="center">::</td></tr></tbody></table></li></ul><h2 id="3-6-网络层其他协议"><a href="#3-6-网络层其他协议" class="headerlink" title="3.6 网络层其他协议"></a>3.6 网络层其他协议</h2><ul><li><p>主机没有 IP 地址但要加入网络时，使用 <code>DHCP</code> ；主机发送数据报但不知目的主机的硬件地址时，使用 <code>ARP</code> ；数据报传输过程中出现差错时，使用 <code>ICMP</code> </p></li><li><p>关于DHCP的描述</p><ul><li>DHCP 允许主机自动从服务器获取 IP 地址</li><li>DHCP 允许地址重复使用</li><li>DHCP 服务器会给出包含配置参数的提议供主机选择</li></ul></li><li><p>每台路由器都依赖 <code>ARP</code> 协议，否则该路由器不能正确工作</p></li><li><p>将 IP 地址转换为物理地址的协议是 <code>ARP</code> ，将物理地址转换为 IP 地址的协议是 <code>RARP</code> </p></li><li><p>关于IP地址与硬件地址的叙述</p><ul><li>IP 地址不能直接用来进行通信，在实际网络的链路上传送数据帧必须使用硬件地址</li><li>硬件地址是数据链路层和物理层使用的地址，IP 地址是网络层和以上各层使用的</li><li>在局域网中，硬件地址又称为物理地址或 MAC 地址 </li></ul></li><li><p> <code>路由器</code> 可以隔离ARP广播帧</p></li><li><p>将主机名转换成 IP 地址，要使用 <code>DNS</code> 协议</p></li><li><p>关于ARP协议的叙述</p><ul><li>由被询问的主机回答 ARP 查询</li><li>给定目的主机的 IP 地址, ARP 可以找到同属一个物理网络内部的目的主机的物理地址</li><li>ARP 采用广播机制</li></ul></li><li><p>应用程序 Ping 发出的是 <code>ICMP请求报文</code> </p></li><li><p>洪泛法的基本思想是 <code>收到的信息都会往所有的可能连结路径上转发</code> </p></li><li><p>ICMP差错报文</p><ul><li>终点不可达：终点不可达分为:网络不可达，主机不可达，协议不可达，端口不可达，需要分片但DF比特已置为1，以及源路由失败等六种情况，其代码字段分别置为0至5。当出现以上六种情况时就向源站发送终点不可达报文。</li><li>端口不可达：UDP的规则之一是：如果收到UDP数据报而且目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP不可达报文。</li><li>源站抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源站发送源站抑制报文，使源站知道应当将数据报的发送速率放慢。</li><li>时间超过：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源站发送时间超过报文。当目的站在预先规定的时间内不能收到一个数据报的全部数据报片时，就将已收到的数据报片都丢弃，并向源站发送时间超过报文。</li><li>参数问题：当路由器或目的主机收到的数据报的首部中的字段的值不正确时，就丢弃该数据报，并向源站发送参数问题报文。</li><li>改变路由（重定向）路由器将改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器。</li></ul><ul><li>以下几种情况都不会导致产生ICMP差错报文<ul><li>ICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）</li><li>目的地址是广播地址或多播地址的IP数据报</li><li>作为链路层广播的数据报</li><li>不是IP分片的第一片</li><li>源地址不是单个主机的数据报。即源地址不能为零地址、环回地址、广播地址或多播地址</li></ul></li></ul></li><li><p>关于IP多播的描述</p><ul><li>IP 多播是指多个接收者可以接收到同一个或者一组源节点发送的相同内容的分组</li><li>支持多播协议的路由器叫做多播路由器</li><li>发送主机使用多播地址发送分组时不需要了解接收者的位置信息与状态信息</li></ul></li><li><p>关于移动IP的描述</p><ul><li>目的地址为家乡地址的 IP 分组，将会以标准的 IP 路由机制发送到家乡网络</li><li>家乡链路与外地链路比家乡网络与外地网络更精确地表示出移动节点接入的位置</li><li>家乡代理通过隧道将发送给移动节点的 IP 分组转发给移动节点</li></ul></li></ul><h1 id="4-传输层与资源分配"><a href="#4-传输层与资源分配" class="headerlink" title="4.传输层与资源分配"></a>4.传输层与资源分配</h1><h2 id="4-1-UDP-协议"><a href="#4-1-UDP-协议" class="headerlink" title="4.1 UDP 协议"></a>4.1 UDP 协议</h2><ul><li>关于UDP的描述<ul><li>发送数据之前不需要建立连接</li><li>相对于 IP 数据报服务，UDP 在 IP 之上只增加了端口的功能和差错检测功能</li><li>UDP 用户数据报只能提供不可靠的交付</li></ul></li><li>关于端口的描述<ul><li>端口就是运输层服务访问点</li><li>端口号只具有本地意义，在因特网中不同计算机的相同端口号是没有联系的</li><li>套接字由 IP 地址和端口号组成</li></ul></li><li>UDP 协议中，伪首部的作用是 <code>为差错检测提供帮助</code> </li><li>为解决 UDP 报文的可靠传输问题，我们可以 <code>合理设计应用层协议</code> </li></ul><h2 id="4-2-TCP协议"><a href="#4-2-TCP协议" class="headerlink" title="4.2 TCP协议"></a>4.2 TCP协议</h2><ul><li><p>TCP/IP 网络中， <code>物理地址</code> 与数据链路层有关， <code>逻辑地址</code> 与网络层有关， <code>端口号</code> 和传输层有关</p></li><li><p>在 TCP/IP 协议族的层次中，解决计算机之间通信问题是在 <code>网际层</code> </p></li><li><p>在 OSI 参考模型中，提供流量控制功能的是 <code>2层（数据链路层）</code> 、 <code>4层（传输层）</code> </p></li><li><p>主机 A 和主机 B 之间建立了一个 TCP 连接，TCP 最大的数据段长度为 1000 字节，若主机 A 当前的拥塞窗口为 4000 字节，在主机 A 向主机 B 连续发送两个最大段之后，成功收到主机 B 回复的第一段的确认，确认报文中通告的接收窗口大小为 2000 字节，则此时主机 A 还可以向主机 B 发送的最大字节数是 <code>1000</code> </p><ul><li>第一个段的确认段中通告的接收窗口大小为2000字节，即表明在接受到第一个报文段后，还有2000字节的缓存空间可用。 由于发送方发送了二个报文段，第二个段将占用剩下的2000字节中的1000字节，即一共还有（ 2000-1000=1000 ）字节，因而，此时主机甲还可以向主机乙发送的最大字节数是1000字节</li></ul></li><li><p>三次握手建立连接</p><ul><li><p>client发送连接建立请求(<strong>SYNbit=1,Seq=x</strong>)至server</p></li><li><p>Server回复确认前序请求(<strong>ACKbit=1,ACKnum=x+1</strong>)，同时请求(<strong>SYNbit=1,Seq=y</strong>)</p></li><li><p>Client回复确认前序请求(<strong>ACKbit=1,ACKnum=y+1</strong>)</p></li></ul></li><li><p>四次握手断开连接</p><ul><li>client发送连接断开请求(<strong>FINbit=1,Seq=u</strong>) 至server</li><li>Server回复确认前序请求(<strong>ACKbit=1,ACKnum=u+1</strong>)，同时继续发送待传输数据(<strong>Seq=v</strong>)</li><li>Server等待上层应用数据传输完毕之后，Server重复确认前序请求(<strong>ACKbit=1,ACKnum=u+1</strong>)，同时发送连接断开请求 (<strong>FINbit=1,Seq=w</strong>)</li><li>Client回复确认前序请求(<strong>ACKbit=1,ACKnum=w+1,Seq=u+1</strong>)，继续等待2MSL时间后关闭</li></ul></li><li><p>IP层负责 <code>主机到主机</code> 的通信，TCP层负责 <code>进程到进程</code> 的通信</p></li><li><p>TCP/IP 为实现高效率的数据传输，在传输层采用了 UDP 协议，其传输的可靠性则由 <code>上层协议</code> 提供</p></li><li><p>TCP传输的可靠是由于使用了 <code>序号</code> 、 <code>确认号</code> </p></li><li><p>TCP可靠重传协议的控制策略</p><ul><li>累计确认重传机制</li><li>校验和</li><li>数据片序号</li></ul></li></ul><h2 id="4-3-拥塞控制"><a href="#4-3-拥塞控制" class="headerlink" title="4.3 拥塞控制"></a>4.3 拥塞控制</h2><ul><li>TCP 的拥塞控制算法中，当拥塞窗口 cwnd 达到 <code>拥塞门槛 ssth</code> 时，进行线性增长</li><li>在进行流量控制和拥塞控制时，发送端的发送窗口上限值应取“接收方窗口”和“拥塞窗口”的 <code>较小的一个</code> </li><li>关于 TCP 拥塞控制方法的描述<ul><li>当已发送报文段的应答到达，拥塞窗口大小加倍</li><li>以分组丢失或超时为拥塞标志</li><li>发送方取“拥塞窗口”和“接收方承认的窗口”两者最小值作为发送窗口 </li></ul></li><li>考虑在一个具有 10ms 往返时延的线路上采用慢启动拥塞机制。假设没有发生网络拥塞，该 TCP 的报文段大小为 2KB，接收方可用接收窗口为 24KB。那么发送方需要 <code>40</code> ms 时间才能达到该接收窗口大小<ul><li>已知最大报文段式2KB，开始的突发量分别是2KB、4KB、8KB、16KB，接下来即为24KB，因为不能超过接收窗口，因此，需要40ms才能发送第一个完全窗口</li></ul></li><li><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0.assets/image-20201129160223986.png"></li><li><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0.assets/image-20201129160254216.png"></li><li><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0.assets/image-20201129160308907.png"></li><li>设 TCP 的拥塞窗口的慢启动门限值初始为 12（单位为报文段），当拥塞窗口达到 16 时出现超时，再次进入慢启动过程。问从这时起，需要 <code>12</code> 次往返时延才能恢复到超时那时的拥塞窗口大小<ul><li>出现超时后，拥塞窗口设为1，拥塞避免门限为8<br>因此经过3个RTT后拥塞窗口增加为8<br>在经过8个RTT后拥塞窗口增加到16<br>因此共需要8+3=11个RTT才能使拥塞窗口恢复为超时时的16</li></ul></li><li>拥塞会引发分组丢失</li><li>TCP协议中观察网络拥塞的办法是 <code>以超时作为网络拥塞的标志</code> </li><li>在 TCP/IP 中，实施流量控制的目的是 <code>保证接收方总是来得及接收发送方发出的报文或分组</code> </li><li>在 TCP 协议中，如果发送窗口直接按照接收方的通知窗口设置，其结果是 <code>突发流量导致分组无法到达接收方</code> </li><li>在 TCP 协议中，如果发送方收到三个重复的 ACK 后, 发送方将会 <code>快速重传未被确认的报文段</code> </li><li>多媒体应用经常不使用 TCP 的原因可能是 <code>不希望数据传输速率受限于拥塞窗口</code> </li></ul><h1 id="5-应用层"><a href="#5-应用层" class="headerlink" title="5.应用层"></a>5.应用层</h1><ul><li>在整个因特网上，使用 <code>IP地址+端口号</code> 可以唯一标识一个特定的应用进程。</li><li>因特网中按 <code>IP地址</code> 进行寻址</li><li>用于 WWW 传输控制的协议是 <code>HTTP</code> </li><li>关于DNS的描述<ul><li>每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录</li><li>当客户请求域名服务器转换名字时，服务器首先按标准过程检查它是否被授权管理该名字</li><li>域名服务器向客户报告缓存中有关名字与地址的绑定(binding)信息</li></ul></li><li>Web 使用 <code>HTTP</code> 协议进行信息传输</li><li>关于 www 的描述<ul><li>浏览器是运行于计算机上的万维网客户端程序；万维网文档所驻留的计算机则运行服务器程序</li><li>WWW 工作过程可简要描述为：浏览器于服务器之间建立 TCP 连接；浏览器发出 HTTP请求报文；服务器给出 HTTP 响应报文；断开 TCP 连接</li><li>一个超文本由多个信息源链接组成，利用一个链接可使用户找到因特网上的另一个文档</li></ul></li><li>在 Internet 域名体系中，域的下面可以划分子域，各级域名用圆点分开，按照 <code>从右到左越来越小的方式分多层排列</code> </li><li>超文本的含义是 <code>该文本中含有链接到其他文本的链接点 </code> </li><li>当一台计算机从 FTP 服务器下载文件时，在该 FTP 服务器上对数据进行封装的五个转换步骤是 <code>消息，报文段，数据报，数据帧，比特</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题之路——1052.爱生气的书店老板</title>
    <link href="/2020/11/26/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%941052.%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/"/>
    <url>/2020/11/26/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%941052.%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>今天，书店老板有一家店打算试营业 <code>customers.length</code> 分钟。每分钟都有一些顾客（ <code>customers[i]</code> ）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p><p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code> ，否则 <code>grumpy[i] = 0</code> 。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 <code>X</code> 分钟不生气，但却只能使用一次。</p><p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p><p>示例：</p><pre><code class="hljs tap">输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3输出：16解释：书店老板在最后<span class="hljs-number"> 3 </span>分钟保持冷静。感到满意的最大客户数量 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 5 </span>= 16.</code></pre><p>提示：</p><ul><li> <code>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000</code> </li><li> <code>0 &lt;= customers[i] &lt;= 1000</code> </li><li> <code>0 &lt;= grumpy[i] &lt;= 1</code> </li></ul><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><h2 id="个人初尝试"><a href="#个人初尝试" class="headerlink" title="个人初尝试"></a>个人初尝试</h2><p>输入： <code> vector&lt;int&gt;&amp;cusstomers、vector&lt;int&gt;&amp;grumpy、int X</code> </p><p>输出： <code>int maxnum</code></p><p>可以看到，在不考虑使用技能的情况下，满意的人数是确定的。很直接一个思路，将确定的满意人数保存下来，采取遍历的方法，每个时段把使用技能后增加的人数加上，得到一个最大的人数返回。</p><p>代码如下：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSatisfied</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; customers, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; grumpy, <span class="hljs-keyword">int</span> X)</span> </span>&#123;        <span class="hljs-comment">//初始化变量</span>        <span class="hljs-keyword">int</span> len = customers.size();<span class="hljs-comment">//时间长度</span>        <span class="hljs-keyword">int</span> basenum = <span class="hljs-number">0</span>;<span class="hljs-comment">//基本的满意人数</span>        <span class="hljs-keyword">int</span> maxnum = <span class="hljs-number">0</span>;<span class="hljs-comment">//最大满意人数</span>        <span class="hljs-comment">//遍历存储不用技能情况下的满意人数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span>(grumpy[i] == <span class="hljs-number">0</span>)                basenum += customers[i];        &#125;        <span class="hljs-comment">//遍历寻找使用技能后最大满意人数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">int</span> tempnum = basenum;<span class="hljs-comment">//寻找最大值的中间变量</span>                        <span class="hljs-comment">//X时间的处理</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; X; j++) &#123;                <span class="hljs-comment">//防止越界</span>                <span class="hljs-keyword">if</span>(i + j &lt; len)&#123;                    <span class="hljs-keyword">if</span>(grumpy[i + j] == <span class="hljs-number">1</span>)<span class="hljs-comment">//如果技能期间本来要生气，加上</span>                        tempnum += customers[i + j];                &#125;            &#125;            <span class="hljs-keyword">if</span>(tempnum &gt; maxnum)<span class="hljs-comment">//如果得到的大于目前最大的，更换目前最大值</span>                maxnum = tempnum;          &#125;    <span class="hljs-keyword">return</span> maxnum;    &#125;&#125;;</code></pre><p>将上述代码提交后，最后一个测试用例超时，查看后发现是一个超长的测试用例，看来还是代码的性能不够。。。。。。没有啥好的思路，学习一下别人的做法</p><h2 id="滑动窗口方法"><a href="#滑动窗口方法" class="headerlink" title="滑动窗口方法"></a>滑动窗口方法</h2><p>滑动窗口方法标准情况下采用<strong>左右窗口指针</strong> <code>left</code> 、 <code>right</code>，用来标记窗口的位置。用 <code>right - left</code> 标志窗口的大小。两指针都从0开始增加， <code>right</code> 先增，当窗口大小超过目标时移动 <code>left</code> 维持窗口大小。每次移动窗口位置都需要判断窗口内需要的信息，是否需要更新需要得到的内容。</p><p>在这个例子中，具体的滑窗实现可以如下：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSatisfied</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; customers, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; grumpy, <span class="hljs-keyword">int</span> X)</span> </span>&#123;        <span class="hljs-comment">//初始化变量,left, right为左右指针，satisfy为满意人数，angry为最大受技能影响的生气人数, anginwindow即技能窗口中的生气人数</span>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, satisfy = <span class="hljs-number">0</span>, angry = <span class="hljs-number">0</span>, anginwindow = <span class="hljs-number">0</span>;        <span class="hljs-comment">//滑窗寻找使用技能后最大满意人数</span>        <span class="hljs-keyword">while</span>(right &lt; customers.size()) &#123;            <span class="hljs-keyword">if</span>(grumpy[right] == <span class="hljs-number">0</span>)<span class="hljs-comment">//不生气的，加入到满意人数中</span>                satisfy += customers[right];                        <span class="hljs-keyword">else</span><span class="hljs-comment">//生气的，加入到受技能影响的生气人数中</span>                anginwindow += customers[right];            ++right;            <span class="hljs-comment">//窗口变化的处理</span>            <span class="hljs-keyword">while</span>(right - left &gt; X) &#123;                <span class="hljs-comment">//此时需要移动左指针，如果左指针有受技能影响的人数，需减去</span>                anginwindow -= grumpy[left]?customers[left]:<span class="hljs-number">0</span>;                ++left;            &#125;            angry = max(angry,anginwindow);<span class="hljs-comment">//每次窗口变化需要更新手机能影响的最大生气人数</span>        &#125;    <span class="hljs-keyword">return</span> satisfy + angry;<span class="hljs-comment">//满意人数+受技能影响最大生气人数即为最大人数</span>    &#125;&#125;;</code></pre><p>这个滑窗虽然能够解决这一问题，且成功通过了所有的用例，但是在效果上不是特别理想，还可以进一步改进。</p><h3 id="该题更进一步的滑窗"><a href="#该题更进一步的滑窗" class="headerlink" title="该题更进一步的滑窗"></a>该题更进一步的滑窗</h3><p>因为题目为固定窗口，所以可以计算出第一个窗口的值作为最大值，然后每次滑动一格算下一个窗口的值，两者比较进行保留，最终得到最大值。</p><p>具体实现代码可以如下：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSatisfied</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; customers, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; grumpy, <span class="hljs-keyword">int</span> X)</span> </span>&#123;        <span class="hljs-comment">//初始化变量,satisfy为最大窗口变满意人数，sinwindow即窗口滑动过程中的变满意人数， basenum为基础满意人数</span>        <span class="hljs-keyword">int</span> satisfy = <span class="hljs-number">0</span>, sinwindow = <span class="hljs-number">0</span>, basenum = <span class="hljs-number">0</span>;        <span class="hljs-comment">//固定滑窗的处理</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ; i &lt; customers.size(); ++i) &#123;            <span class="hljs-keyword">if</span>(grumpy[i])<span class="hljs-comment">//计算窗口内此刻的生气变满意人数，相当于右指针每次增加最右侧值</span>                sinwindow += customers[i];            <span class="hljs-keyword">else</span><span class="hljs-comment">//计算基础满意人数</span>                basenum += customers[i];                        <span class="hljs-comment">//开始超出窗口大小，每次需要按要求减去最左侧，并比较得出最大窗口变满意人数</span>            <span class="hljs-keyword">if</span>(i &gt;= X<span class="hljs-number">-1</span>) &#123;                satisfy = max(satisfy, sinwindow);                sinwindow -= grumpy[i-(X<span class="hljs-number">-1</span>)]?customers[i-(X<span class="hljs-number">-1</span>)]:<span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-comment">//最大值就是基础满意人数加最大窗口变满意人数</span>        <span class="hljs-keyword">return</span> satisfy + basenum;    &#125;&#125;;</code></pre><h1 id="一些小细节总结"><a href="#一些小细节总结" class="headerlink" title="一些小细节总结"></a>一些小细节总结</h1><ul><li><code>vector</code> 初始化用 <code>&#123;&#125;</code> 而不是 <code>[]</code></li><li>类&amp;对象需要先声明，就像声明基本类型的变量一样</li><li> <code>using name space std</code> 还是挺方便的，可用</li><li> <code>vector</code> 的名字本身就是一个指针，传参不需要加 <code>*</code> </li><li> <code>if</code> 和 <code>? :</code> ， <code>if</code> 是用于不同逻辑代码段，而  <code>? :</code> 用于不同逻辑赋值</li><li><code>i++</code> 和 <code>++i</code> ，在如 <code>for</code> 循环的使用中，用 <code>++i</code> 性能更好，原因如下：<ul><li>  <code>i++</code> 由于是在使用当前值之后再 <code>+1</code> ，所以需要一个临时的变量来转存</li><li> 而 <code>++i</code> 则是在直接 <code>+1</code> ，省去了对内存的操作的环节，相对而言能够提高性能</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sony Xperia 5 II 内置软件卸载</title>
    <link href="/2020/11/15/Sony%20Xperia%205%20II%20%E5%86%85%E7%BD%AE%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/"/>
    <url>/2020/11/15/Sony%20Xperia%205%20II%20%E5%86%85%E7%BD%AE%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>入手港版Sony后有一些我用不到的软件，又不想root，利用adb卸载。</p><a id="more"></a><h1 id="下载adb工具包"><a href="#下载adb工具包" class="headerlink" title="下载adb工具包"></a>下载adb工具包</h1><p>这玩意儿网上百度一大堆，下一个就好了。应该是个压缩包，解压到你知道的地方即可</p><h1 id="手机准备"><a href="#手机准备" class="headerlink" title="手机准备"></a>手机准备</h1><p>首先，手机要打开 <code>开发者选项</code> ，通常应该是点击版本号5下即可，具体的请自行百度</p><p>随后，进入 <code>开发者选下</code> ，打开 <code>USB调试</code></p><p>请下载一个包名查看软件，后面删除包需要用这类软件来查看包名</p><h1 id="删除流程"><a href="#删除流程" class="headerlink" title="删除流程"></a>删除流程</h1><ul><li><p>手机连接电脑</p></li><li><p>在解压adb的文件夹打开 <code>cmd</code> </p></li><li><p>输入如下命令</p><pre><code class="hljs powershell">adb devices</code></pre><p>能够看到自己的设备，说明连接成功。若未看到，请检查手机准备步骤是否完成</p></li><li><p>连接设备</p><pre><code class="hljs powershell">adb shell</code></pre></li><li><p>删除命令如下</p><pre><code class="hljs powershell">pm uninstall <span class="hljs-literal">-k</span> -<span class="hljs-literal">-user</span> <span class="hljs-number">0</span> 应用包名</code></pre><p>这个包名不是应用的名字，具体的格式可以用如下命令查看</p><pre><code class="hljs powershell">pm list packages</code></pre><p>所以具体要删除啥，就用下载的包名查看软件看即可</p></li></ul><h1 id="我删除的软件"><a href="#我删除的软件" class="headerlink" title="我删除的软件"></a>我删除的软件</h1><pre><code class="hljs powershell"><span class="hljs-comment"># Call of Duty</span>com.activision.callofduty.shooter<span class="hljs-comment"># LinkedIN</span>com.linkedin.android<span class="hljs-comment"># TIDAL 3 Months Free</span>com.android.tidal.campaigninstaller<span class="hljs-comment"># Netflix</span>com.netflix.mediaclient<span class="hljs-comment"># Google地图</span>com.google.android.apps.maps<span class="hljs-comment"># 数字健康</span>com.google.android.apps.wellbeing<span class="hljs-comment"># 智能镜头</span>com.google.ar.lens<span class="hljs-comment"># Google Play Service for AR</span>com.google.ar.core<span class="hljs-comment"># Google</span>com.google.android.googlequicksearchbox<span class="hljs-comment"># Chrome</span>com.android.chrome<span class="hljs-comment"># 相册</span>com.google.android.apps.photos<span class="hljs-comment"># 文件</span>com.google.android.documentsui</code></pre>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pluto环境搭建</title>
    <link href="/2020/11/09/pluto%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/11/09/pluto%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>本文旨在帮助刚入手pluto的同志们搭建好pluto的工作环境，便于后续的在matlab下开发测试。</p><a id="more"></a><h1 id="USB驱动安装"><a href="#USB驱动安装" class="headerlink" title="USB驱动安装"></a>USB驱动安装</h1><p>安装pluto的USB驱动 <code>PlutoSDR-M2k-USB-Drivers.exe</code> ，需要的资源在 <a href="https://github.com/analogdevicesinc/plutosdr-m2k-drivers-win/releases">github页</a> 可以下载。安装过程极其简单，一路默认next就可以了。</p><p>安装完成后，可以在设备管理器看到如下图的设备（当然需要连接上pluto），就说明安装成功了。</p><p><img src="/img/pluto%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.assets/image-20201108132710358.png"></p><p><img src="/img/pluto%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.assets/image-20201108132742781.png"></p><p>同时，我们会看到如下的PlutoSDR存储盘：</p><p><img src="/img/pluto%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.assets/image-20201108132822198.png"></p><h1 id="OSC上位机安装"><a href="#OSC上位机安装" class="headerlink" title="OSC上位机安装"></a>OSC上位机安装</h1><p>安装Pluto官方的上位机管理软件 <code>adi-osc-setup.exe</code> ，需要的资源在 <a href="https://wiki.analog.com/resources/tools-software/linux-software/iio_oscilloscope">官方网站</a> 可以下载。安装过程也没啥好说的，选择合适的路径一路默认即可。</p><h1 id="libiio驱动安装"><a href="#libiio驱动安装" class="headerlink" title="libiio驱动安装"></a>libiio驱动安装</h1><p>安装所需的libiio驱动 <code>libiio-0.21.g565bf68-Windows-setup.exe</code> ，需要的资源在 <a href="https://github.com/analogdevicesinc/libiio/releases/tag/0.21">github页</a> 可以下载。一路默认完事儿了。</p><h1 id="MATLAB安装"><a href="#MATLAB安装" class="headerlink" title="MATLAB安装"></a>MATLAB安装</h1><p>这就不用我说了吧，安装要求的版本，我们这次是 <code>R2018b</code> ，相关安装的教程资料网上一大堆，不过多赘述。</p><h1 id="TDM-GCC编译器安装"><a href="#TDM-GCC编译器安装" class="headerlink" title="TDM-GCC编译器安装"></a>TDM-GCC编译器安装</h1><p>安装所需的编译器 <code>tdm64-gcc-9.2.0.exe</code> ，需要的资源在 <a href="https://jmeubank.github.io/tdm-gcc/">官方网站</a> 可以下载。</p><h2 id="编译器的安装"><a href="#编译器的安装" class="headerlink" title="编译器的安装"></a>编译器的安装</h2><ul><li><p>点击 <code>Create</code> </p><p><img src="/img/pluto%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.assets/image-20201108134436530.png"></p></li><li><p>选择安装的编译器类型，这里选择第二项</p><p><img src="/img/pluto%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.assets/image-20201108134532959.png"></p></li><li><p>选择安装路径，注意<strong>不要用中文，也不要有空格！</strong>默认的路径其实已经可以了，如果需要更改尽量只更改安装盘，不更改文件夹命名</p><p><img src="/img/pluto%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.assets/image-20201108134753307.png"></p></li><li><p>后面一路默认安装即可，可能安装的时间会比较长，耐心等待</p></li></ul><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><ul><li><p>打开 <code>此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量</code> </p><p><img src="/img/pluto%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.assets/image-20201108135210921.png"></p></li><li><p>新建环境变量，如下配置。注意<strong>变量值为TDM-GCC编译器安装文件夹，一定要一致！</strong></p><p><img src="/img/pluto%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.assets/image-20201108135344804.png"></p></li></ul><h2 id="MATLAB配置"><a href="#MATLAB配置" class="headerlink" title="MATLAB配置"></a>MATLAB配置</h2><ul><li><p>设置环境变量，输入以下命令</p><pre><code class="hljs matlab">#第一个参数是我们的环境变量名，第二个参数是我们的安装路径setenv(<span class="hljs-string">&#x27;MW_MINGW64_LOC&#x27;</span>,<span class="hljs-string">&#x27;C:\TDM-GCC-64&#x27;</span>);mex -setup</code></pre></li><li><p>在弹出的选项中选择C++语言，点击即可</p><p><img src="/img/pluto%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.assets/image-20201108140126264.png"></p></li></ul><h1 id="安装Matlab依赖包"><a href="#安装Matlab依赖包" class="headerlink" title="安装Matlab依赖包"></a>安装Matlab依赖包</h1><p>记住要安装Matlab的官方依赖包，我们这次是ADI官方提供的依赖包，官网应该也有提供的下载，这里就不在列出</p><h1 id="配置完成"><a href="#配置完成" class="headerlink" title="配置完成"></a>配置完成</h1><p>至此，整个环境配置完成，愉快的去造作吧！</p>]]></content>
    
    
    <categories>
      
      <category>ADI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pluto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>alias命令</title>
    <link href="/2020/10/30/alias%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/10/30/alias%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>众所周知，Linux下的解压命令多又难记，时不时还有用错的情况。在邓迅邓巨神的指点下，知晓了 <code>alias</code> 这个神奇的命令，使用起来确实方便了许多，遂记下！</p><h1 id="查看当前已设置的别名"><a href="#查看当前已设置的别名" class="headerlink" title="查看当前已设置的别名"></a>查看当前已设置的别名</h1><pre><code class="hljs bash">alex@PC-20200316LEME:~$ <span class="hljs-built_in">alias</span><span class="hljs-built_in">alias</span> alert=<span class="hljs-string">&#x27;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &#x27;</span>\<span class="hljs-string">&#x27;&#x27;</span>s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//<span class="hljs-string">&#x27;\&#x27;</span><span class="hljs-string">&#x27;)&quot;&#x27;</span><span class="hljs-built_in">alias</span> egrep=<span class="hljs-string">&#x27;egrep --color=auto&#x27;</span><span class="hljs-built_in">alias</span> fgrep=<span class="hljs-string">&#x27;fgrep --color=auto&#x27;</span><span class="hljs-built_in">alias</span> grep=<span class="hljs-string">&#x27;grep --color=auto&#x27;</span><span class="hljs-built_in">alias</span> l=<span class="hljs-string">&#x27;ls -CF&#x27;</span><span class="hljs-built_in">alias</span> la=<span class="hljs-string">&#x27;ls -A&#x27;</span><span class="hljs-built_in">alias</span> lh=<span class="hljs-string">&#x27;ls -lh&#x27;</span><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">&#x27;ls -alF&#x27;</span><span class="hljs-built_in">alias</span> ls=<span class="hljs-string">&#x27;ls --color=auto&#x27;</span><span class="hljs-built_in">alias</span> tarbz2=<span class="hljs-string">&#x27;tar -jxvf&#x27;</span></code></pre><p>直接输入 <code>alias</code> 即可查看已经设置的别名，已经设置好的别名我们可以直接使用。例如，我输入命令 <code>ll</code> ，就相当于输入 <code>ls -alF</code> 。</p><h1 id="为命令设置别名"><a href="#为命令设置别名" class="headerlink" title="为命令设置别名"></a>为命令设置别名</h1><pre><code class="hljs bash">alex@PC-20200316LEME:~$ <span class="hljs-built_in">alias</span> vi=<span class="hljs-string">&#x27;vim&#x27;</span>alex@PC-20200316LEME:~$ <span class="hljs-built_in">alias</span><span class="hljs-built_in">alias</span> alert=<span class="hljs-string">&#x27;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &#x27;</span>\<span class="hljs-string">&#x27;&#x27;</span>s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//<span class="hljs-string">&#x27;\&#x27;</span><span class="hljs-string">&#x27;)&quot;&#x27;</span><span class="hljs-built_in">alias</span> egrep=<span class="hljs-string">&#x27;egrep --color=auto&#x27;</span><span class="hljs-built_in">alias</span> fgrep=<span class="hljs-string">&#x27;fgrep --color=auto&#x27;</span><span class="hljs-built_in">alias</span> grep=<span class="hljs-string">&#x27;grep --color=auto&#x27;</span><span class="hljs-built_in">alias</span> l=<span class="hljs-string">&#x27;ls -CF&#x27;</span><span class="hljs-built_in">alias</span> la=<span class="hljs-string">&#x27;ls -A&#x27;</span><span class="hljs-built_in">alias</span> lh=<span class="hljs-string">&#x27;ls -lh&#x27;</span><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">&#x27;ls -alF&#x27;</span><span class="hljs-built_in">alias</span> ls=<span class="hljs-string">&#x27;ls --color=auto&#x27;</span><span class="hljs-built_in">alias</span> tarbz2=<span class="hljs-string">&#x27;tar -jxvf&#x27;</span><span class="hljs-built_in">alias</span> vi=<span class="hljs-string">&#x27;vim&#x27;</span></code></pre><p>这个例子我们给 <code>vim</code> 设置了一个别名 <code>vi</code> ，注意设置时等号左右不要有空格。此时我们输入 <code>vi</code> 命令就相当于输入 <code>vim</code> 命令。</p><h1 id="删除设置的别名"><a href="#删除设置的别名" class="headerlink" title="删除设置的别名"></a>删除设置的别名</h1><pre><code class="hljs bash">alex@PC-20200316LEME:~$ <span class="hljs-built_in">unalias</span> vialex@PC-20200316LEME:~$ <span class="hljs-built_in">alias</span><span class="hljs-built_in">alias</span> alert=<span class="hljs-string">&#x27;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &#x27;</span>\<span class="hljs-string">&#x27;&#x27;</span>s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//<span class="hljs-string">&#x27;\&#x27;</span><span class="hljs-string">&#x27;)&quot;&#x27;</span><span class="hljs-built_in">alias</span> egrep=<span class="hljs-string">&#x27;egrep --color=auto&#x27;</span><span class="hljs-built_in">alias</span> fgrep=<span class="hljs-string">&#x27;fgrep --color=auto&#x27;</span><span class="hljs-built_in">alias</span> grep=<span class="hljs-string">&#x27;grep --color=auto&#x27;</span><span class="hljs-built_in">alias</span> l=<span class="hljs-string">&#x27;ls -CF&#x27;</span><span class="hljs-built_in">alias</span> la=<span class="hljs-string">&#x27;ls -A&#x27;</span><span class="hljs-built_in">alias</span> lh=<span class="hljs-string">&#x27;ls -lh&#x27;</span><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">&#x27;ls -alF&#x27;</span><span class="hljs-built_in">alias</span> ls=<span class="hljs-string">&#x27;ls --color=auto&#x27;</span><span class="hljs-built_in">alias</span> tarbz2=<span class="hljs-string">&#x27;tar -jxvf&#x27;</span></code></pre><p>使用 <code>unalias</code> 就可以删除我们已经设置好的别名。</p><h1 id="让别名永久生效（当然，别删除它）"><a href="#让别名永久生效（当然，别删除它）" class="headerlink" title="让别名永久生效（当然，别删除它）"></a>让别名永久生效（当然，别删除它）</h1><p>按照上面的方法生成的别名，在我们重启电脑后就会失效。怎么样才能让他一直生效呢？当然是把它加入到会自动运行的脚本中！ <code>~/.bashrc</code> 就是一个不错的选择。</p><p>打开 <code>~/.bashrc</code> ：</p><pre><code class="hljs bash">vim ~/.bashrc</code></pre><p>可以看到一些已经写入在这个脚本中的 <code>alias</code> 命令：</p><pre><code class="hljs bash">···<span class="hljs-comment"># some more ls aliases</span><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">&#x27;ls -alF&#x27;</span><span class="hljs-built_in">alias</span> la=<span class="hljs-string">&#x27;ls -A&#x27;</span><span class="hljs-built_in">alias</span> lh=<span class="hljs-string">&#x27;ls -lh&#x27;</span><span class="hljs-built_in">alias</span> l=<span class="hljs-string">&#x27;ls -CF&#x27;</span><span class="hljs-comment">#下面这行是我自己加入的alia命令，用来解压.tar.bz2的压缩包</span><span class="hljs-built_in">alias</span> tarbz2=<span class="hljs-string">&#x27;tar -jxvf&#x27;</span>···</code></pre><p>现在在这个脚本中加入自己想用的别名吧！之后每次只要你是用这个账户登录的Linux，就可以使用这些设置的别名。面对那些复杂的压缩解压命令等等，碰到一个就加入进来吧！</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>setlocale warning</title>
    <link href="/2020/10/27/setlocale%20warning/"/>
    <url>/2020/10/27/setlocale%20warning/</url>
    
    <content type="html"><![CDATA[<p>小系统登陆时出现多条如下warning:</p><pre><code class="hljs bash">-bash:warning:setlocale:LC_CTYPE:connot change locale (en_US.UTF-8):No such file or directory</code></pre><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><pre><code class="hljs bash"><span class="hljs-comment"># 打开小系统里的i18n</span>vi /etc/sysconfig/i18n<span class="hljs-comment"># 添加下面的</span>LC_ALL=C<span class="hljs-built_in">export</span> LC_ALL</code></pre><p>重新打包后问题解决。</p><h1 id="LC-ALL-C"><a href="#LC-ALL-C" class="headerlink" title="LC_ALL = C"></a><code>LC_ALL = C</code></h1><p>之前的报错说明我们本身的小系统里没有安装en_US的local，使用 <code>LC_ALL = C</code> 是为了去除所有本地化的设置，让命令能正确执行。</p><p>在Linux中通过 <code>locale</code> 来设置程序运行的不同语言环境， <code>locale</code> 由ANSI C提供支持。 <code>locale</code> 的命名规则为 <code>&lt;语言&gt;_&lt;地区&gt;.&lt;字符集编码&gt;</code> ，如 <code>zh_CN.UTF-8</code> ，zh代表中文，CN代表大陆地区，UTF-8表示字符集。在 <code>locale</code> 环境中，有一组变量，代表国际化环境中的不同设置：</p><ul><li><p> <code>LC_COLLATE</code><br>定义该环境的排序和比较规则</p></li><li><p> <code>LC_CTYPE</code><br>用于字符分类和字符串处理，控制所有字符的处理方式，包括字符编码，字符是单字节还是多字节，如何打印等。是最重要的一个环境变量。</p></li><li><p> <code>LC_MONETARY</code><br>货币格式</p></li><li><p> <code>LC_NUMERIC</code><br>非货币的数字显示格式</p></li><li><p> <code>LC_TIME</code><br>时间和日期格式</p></li><li><p> <code>LC_MESSAGES</code><br>提示信息的语言。另外还有一个 <code>LANGUAGE</code> 参数，它与 <code>LC_MESSAGES</code> 相似，但如果该参数一旦设置，则 <code>LC_MESSAGES</code> 参数就会失效。 <code>LANGUAGE</code> 参数可同时设置多种语言信息，如 <code>LANGUANE=&quot;zh_CN.GB18030:zh_CN.GB2312:zh_CN&quot;</code> 。</p></li><li><p><code>LANG</code><br><code>LC_*</code> 的默认值，是最低级别的设置，如果 <code>LC_*</code> 没有设置，则使用该值。类似于 <code>LC_ALL</code> 。</p></li><li><p> <code>LC_ALL</code><br>它是一个宏，如果该值设置了，则该值会覆盖所有 <code>LC_*</code> 的设置值。注意， <code>LANG</code> 的值不受该宏影响。</p></li></ul><p>“C”是系统默认的 <code>locale</code> ，”POSIX”是”C”的别名。所以当我们新安装完一个系统时，默认的 <code>locale</code> 就是 <code>C</code> 或 <code>POSIX</code> 。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的摇滚歌单</title>
    <link href="/2020/10/27/%E6%88%91%E7%9A%84%E6%91%87%E6%BB%9A%E6%AD%8C%E5%8D%95/"/>
    <url>/2020/10/27/%E6%88%91%E7%9A%84%E6%91%87%E6%BB%9A%E6%AD%8C%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<p>近期看了《波西米亚狂想曲》，听了1985年的live aid演唱会，被Queen给洗脑了，进而对于摇滚乐起了浓厚的兴趣。记录一下自己喜欢的摇滚歌单。</p><a id="more"></a><p>说是摇滚歌单，但我觉得有些歌其实不算我心里摇滚的概念？不过，管它的呢。</p><h1 id="Queen"><a href="#Queen" class="headerlink" title="Queen"></a>Queen</h1><ul><li>One vision</li><li>Tie your mother down</li><li>In the lap of the gods - revisited</li><li>Seven Seas of Rhyne</li><li>Tear it Up</li><li>A Kind of Magic</li><li>Under Pressure</li><li>Who Wants to Live Forever</li><li>I Want to Break Free</li><li>Now i’m Here</li><li>Love of My Life</li><li>Is This the World We Created?</li><li>Tutti Frutti</li><li>Bohemian Rhapsody</li><li>Hammer to Fall</li><li>Crazy Little Thing Called Love</li><li>Radio Ga Ga</li><li>We Will Rock You</li><li>Friends Will be Friends</li><li>We are The Champions</li><li>Play the Game</li><li>Somebody to Love</li><li>Killer Queen</li><li>Save Me</li><li>Keep Yourself Alive</li><li>Jailhouse Rock</li><li>Another One Bites the Dust</li></ul><h1 id="Beatle"><a href="#Beatle" class="headerlink" title="Beatle"></a>Beatle</h1><ul><li>Hello, Goodbye</li><li>Lady Madonna</li><li>Something</li><li>Help!</li><li>Let it be</li><li>She loves you</li><li>Twist and shout</li><li>Can’t buy me love</li><li>Get back</li><li>The long and winding road</li><li>Eight days a week</li><li>Hey Bulldog</li><li>I’ve got a feeling</li><li>Yesterday</li><li>Hey Jude</li></ul><h1 id="Linkin-Park"><a href="#Linkin-Park" class="headerlink" title="Linkin Park"></a>Linkin Park</h1><ul><li>In The End</li></ul><h1 id="Bon-Jovi"><a href="#Bon-Jovi" class="headerlink" title="Bon Jovi"></a>Bon Jovi</h1><ul><li>It’s my life</li></ul><h1 id="Michael-Jackson"><a href="#Michael-Jackson" class="headerlink" title="Michael Jackson"></a>Michael Jackson</h1><ul><li>Beat it</li></ul><h1 id="Eagles"><a href="#Eagles" class="headerlink" title="Eagles"></a>Eagles</h1><ul><li>Hotel California</li></ul>]]></content>
    
    
    <categories>
      
      <category>Music</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Music</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux小系统网络配置问题</title>
    <link href="/2020/10/25/Linux%E5%B0%8F%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <url>/2020/10/25/Linux%E5%B0%8F%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在裁剪好内核，和外围文件系统一起启动后，发现 <code>service</code> 命令以及网络配置都无法实现，进行调试。</p><a id="more"></a><h1 id="service-命令使用后无任何输出"><a href="#service-命令使用后无任何输出" class="headerlink" title="service 命令使用后无任何输出"></a><code>service</code> 命令使用后无任何输出</h1><p>查看 <code>/sbin/service</code> ，其调用 <code>/etc/init.d/functions</code> 。为了定位问题所在，查看 <code>functions</code> ，发现它所有的错误输出都送到了 <code>/dev/null</code> （黑洞），没有显示出来。将所有的 <code>2&gt;/dev/null</code> 删去，查看到了错误信息，缺少 <code>/etc/profile.d/lang.sh</code> 。为了避免再出现相同位置的文件缺失，直接将 <code>/etc/profile.d</code>  拷入到小系统中，service能够正常的运行了。</p><h1 id="service-network-命令无法正常运行"><a href="#service-network-命令无法正常运行" class="headerlink" title="service network 命令无法正常运行"></a><code>service network</code> 命令无法正常运行</h1><p>在 <code>service</code> 能够运行后，使用 <code>service network</code> 、 <code>service network start</code> 等命令是无法正常运行的，会报错缺少某些命令或文件。按照报错信息将缺少的命令和文件补全。以下是我拷贝的一些：</p><pre><code class="hljs shell">envsort/bin/ipcalcgrep/var/run/netreportegrep/sbin/arpingpidof</code></pre><h1 id="service-ssh-命令无法正常运行"><a href="#service-ssh-命令无法正常运行" class="headerlink" title="service ssh 命令无法正常运行"></a><code>service ssh</code> 命令无法正常运行</h1><p>完成上述两个步骤后，已经可以利用 <code>service network</code> 命令配置好小系统的网络了，从主机ping可以ping通相应的IP。但是直接用ssh还无法链接，同样进行调试，查看报错进行拷贝。以下是我拷贝的一些：</p><pre><code class="hljs shell">/usr/bin/dirname</code></pre><p>拷贝完成后，现在运行 <code>service ssh restart</code> 只会提示：</p><pre><code class="hljs shell">Stopping sshd: [FAILED]</code></pre><p>由于没有更多的报错信息，难以进行调试，查看 <code>/etc/init.d/sshd</code> 脚本内容：</p><pre><code class="hljs shell">vi /etc/init.d/sshd</code></pre><p>在脚本开头可以看到一些说明信息：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment">#</span><span class="hljs-comment"># sshd          Start up the OpenSSH server daemon</span><span class="hljs-comment">#</span><span class="hljs-comment"># chkconfig: 2345 55 25</span><span class="hljs-comment"># description: SSH is a protocol for secure remote shell access. \</span><span class="hljs-comment">#              This service starts up the OpenSSH server daemon.</span><span class="hljs-comment">#</span><span class="hljs-comment"># processname: sshd</span><span class="hljs-comment"># config: /etc/ssh/ssh_host_key</span><span class="hljs-comment"># config: /etc/ssh/ssh_host_key.pub</span><span class="hljs-comment"># config: /etc/ssh/ssh_random_seed</span><span class="hljs-comment"># config: /etc/ssh/sshd_config</span><span class="hljs-comment"># pidfile: /var/run/sshd.pid</span><span class="hljs-comment">### BEGIN INIT INFO</span><span class="hljs-comment"># Provides: sshd</span><span class="hljs-comment"># Required-Start: $local_fs $network $syslog</span><span class="hljs-comment"># Required-Stop: $local_fs $syslog</span><span class="hljs-comment"># Should-Start: $syslog</span><span class="hljs-comment"># Should-Stop: $network $syslog</span><span class="hljs-comment"># Default-Start: 2 3 4 5</span><span class="hljs-comment"># Default-Stop: 0 1 6</span><span class="hljs-comment"># Short-Description: Start up the OpenSSH server daemon</span><span class="hljs-comment"># Description:       SSH is a protocol for secure remote shell access.</span><span class="hljs-comment">#                    This service starts up the OpenSSH server daemon.</span><span class="hljs-comment">### END INIT INFO</span></code></pre><p>可以看到相关的配置文件在 <code>/etc/ssh</code> 文件夹下，拷贝至小系统后再次尝试，可以看到新的有用报错信息了，继续拷贝。以下是我拷贝的一些命令：</p><pre><code class="hljs shell">usleepsleep</code></pre><h1 id="ssh无法连接"><a href="#ssh无法连接" class="headerlink" title="ssh无法连接"></a>ssh无法连接</h1><p>完成上面的操作后，ssh连接会提示输入密码，输入密码后会卡住在如下命令：</p><pre><code class="hljs shell">PTY allocation request failed on channel 0</code></pre><p>但是在ssh连接命令上加上 <code>-T</code> 就可以顺利进行连接。</p><p>查阅说明：</p><pre><code class="hljs bash">-T Disable pseudo-tty allocation.</code></pre><p> <code>-T</code> 意思是禁止分配伪终端。当用ssh或telnet等登录系统时，系统分配给我们的终端就是伪终端。 如果ssh使用此选项登录系统时，由于禁用，将无法获得终端；但仍能够获得shell，只不过看起来像在本地，也没有很多应有的环境变量，例如命令提示符，PS1等。</p><p>于是猜测仍然是与ssh相关的依赖没有拷完。使用如下命令查看ssh依赖：</p><pre><code class="hljs shell">[root@localhost ~]# rpm -ql openssh/etc/ssh/etc/ssh/moduli/usr/bin/ssh-keygen/usr/libexec/openssh/usr/libexec/openssh/ssh-keysign/usr/share/doc/openssh-5.3p1/usr/share/doc/openssh-5.3p1/CREDITS/usr/share/doc/openssh-5.3p1/ChangeLog/usr/share/doc/openssh-5.3p1/INSTALL/usr/share/doc/openssh-5.3p1/LICENCE/usr/share/doc/openssh-5.3p1/OVERVIEW/usr/share/doc/openssh-5.3p1/PROTOCOL/usr/share/doc/openssh-5.3p1/PROTOCOL.agent/usr/share/doc/openssh-5.3p1/PROTOCOL.certkeys/usr/share/doc/openssh-5.3p1/README/usr/share/doc/openssh-5.3p1/README.dns/usr/share/doc/openssh-5.3p1/README.nss/usr/share/doc/openssh-5.3p1/README.platform/usr/share/doc/openssh-5.3p1/README.privsep/usr/share/doc/openssh-5.3p1/README.smartcard/usr/share/doc/openssh-5.3p1/README.tun/usr/share/doc/openssh-5.3p1/TODO/usr/share/doc/openssh-5.3p1/WARNING.RNG/usr/share/man/man1/ssh-keygen.1.gz/usr/share/man/man8/ssh-keysign.8.gz</code></pre><p>去除相关的文档和 <code>man</code> ，剩下没有的我们就补上。补全后问题仍然没有解决。</p><p>在小系统中输入 <code>mount</code> ，可以看到已经挂载的磁盘：</p><pre><code class="hljs shell">/dev/sda1 on / type ext4 (rw)proc on /proc type proc (rw)sysfs on /sys type sysfs (rw)devpts on /dev/pts type devpts (rw,gid=5,mode=620)tmpfs on /dev/shm type tmpfs (rw)none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)</code></pre><p>奇怪的事情来了，明明已经挂载了 <code>/dev/pts</code> ，但是在 <code>/dev</code> 下却并没有出现 <code>pts</code> 文件夹，推测这就是问题的根源所在！</p><p>尝试在打包前直接新建 <code>/dev/pts</code> 目录，但是并没有用。。。。。。最后在测试小系统 <code>mkdir</code> 命令时意外发现居然失效了？！重新拷贝一次 <code>mkdir</code> 命令，问题最终解决！</p><p>最后删去打包前新建的 <code>/dev/pts</code> 目录，裁剪驱动后重新打包，可以正常运行。看来就是 <code>mkdir</code> 命令失效带来的问题了。。。。。。挺好奇为啥会失效的，可惜目前没办法复现。</p><p>至此，已经可以实现ssh直接连接小系统了。但目前的系统缺陷如下：</p><ul><li>开机不能自动配置好network和sshd，需要手动使用 <code>service</code> 命令实现</li><li>登录过程中和登陆后存在一些warning输出，虽然不影响使用，但最好还是可以解决</li></ul><p>以上缺陷等待后续处理吧！</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>libpcap离线包排序</title>
    <link href="/2020/10/23/%E5%9C%A8libpcap%E4%B8%8B%E5%AE%9E%E7%8E%B0%E7%A6%BB%E7%BA%BF%E6%B5%81%E9%87%8F%E5%8C%85%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/10/23/%E5%9C%A8libpcap%E4%B8%8B%E5%AE%9E%E7%8E%B0%E7%A6%BB%E7%BA%BF%E6%B5%81%E9%87%8F%E5%8C%85%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>libpcap是unix/linux平台下的网络数据包捕获函数包，大多数网络监控软件都以它为基础。原先的在python下用scapy读包效率过低，故转用在C下由libpcap实现读包排序。</p><a id="more"></a><h1 id="libpcap安装"><a href="#libpcap安装" class="headerlink" title="libpcap安装"></a>libpcap安装</h1><pre><code class="hljs bash">wget https://www.tcpdump.org/release/libpcap-1.9.1.tar.gztar zxvf libpcap-1.9.1.tar.gz<span class="hljs-built_in">cd</span> libpcap-1.9.1/./configuresudo makesudo make install</code></pre><h1 id="libpcap的一些关键函数"><a href="#libpcap的一些关键函数" class="headerlink" title="libpcap的一些关键函数"></a>libpcap的一些关键函数</h1><h2 id="1-获取网络接口"><a href="#1-获取网络接口" class="headerlink" title="1.获取网络接口"></a><strong>1.获取网络接口</strong></h2><p><code>char * pcap_lookupdev(char * errbuf)</code></p><p>返回第一个合适的网络接口的字符串指针，如果出错，则errbuf存放出错信息字符串，errbuf至少应该是PCAP_ERRBUF_SIZE个字节长度的</p><h2 id="2-释放网络接口"><a href="#2-释放网络接口" class="headerlink" title="2.释放网络接口"></a><strong>2.释放网络接口</strong></h2><p><code>void pcap_close(pcap_t * p)</code></p><p>关闭pcap_open_live()获取的pcap_t的网络接口对象并释放相关资源</p><h2 id="3-读取本地pcap文件"><a href="#3-读取本地pcap文件" class="headerlink" title="3.读取本地pcap文件"></a><strong>3.读取本地pcap文件</strong></h2><p><code>pcap_t * pcap_open_offline(const char *fname, char *errbuf)</code></p><p>函数打开保存的数据包文件，用于读取，返回文件描述符</p><p>fname参数指定了pcap文件名</p><p>errbuf依旧是函数出错的时候返回错误信息</p><h2 id="4-获取数据包"><a href="#4-获取数据包" class="headerlink" title="4.获取数据包"></a><strong>4.获取数据包</strong></h2><p><code>int pcap_loop(pcap_t * p, int cnt, pcap_handler callback, u_char * user)</code></p><p><strong>第一个参数</strong>是第2步返回的pcap_t类型的指针<br><strong>第二个参数</strong>是需要抓的数据包的个数，一旦抓到了cnt个数据包，pcap_loop立即返回。负数的cnt表示pcap_loop永远循环抓包，直到出现错误。<br><strong>第三个参数</strong>是一个回调函数指针，它必须是如下的形式：<br><code>void callback(u_char * userarg, const struct pcap_pkthdr * pkthdr, const u_char * packet)</code></p><ul><li><strong>第一个参数是</strong>pcap_loop的最后一个参数，当收到足够数量的包后pcap_loop会调用callback回调函数，同时将pcap_loop()的user参数传递给它</li><li><strong>第二个参数</strong>是收到的数据包的pcap_pkthdr类型的指针</li><li><strong>第三个参数</strong>是收到的数据包数据</li></ul><h2 id="5-保存数据包"><a href="#5-保存数据包" class="headerlink" title="5.保存数据包"></a><strong>5.保存数据包</strong></h2><p><code>pcap_dumper_t *pcap_dump_open(pcap_t *p, const char *file)</code></p><p>函数返回pcap_dumper_t类型的指针，file是文件名，可以是绝对路径</p><p><code>void  pcap_dump_close(pcap_dumper_t *p)</code></p><p>用来关闭pcap_dump_open打开的文件，入参是pcap_dump_open返回的指针</p><p><code>int pcap_dump_flush(pcap_dumper_t *p)</code></p><p>刷新缓冲区，把捕获的数据包从缓冲区真正拷贝到文件</p><p><code>void  pcap_dump(u_char * userarg, const struct pcap_pkthdr * pkthdr, const u_char * packet)</code></p><p>输出数据到文件，与pcap_loop的第二个参数回调函数<code>void callback(u_char * userarg, const struct pcap_pkthdr * pkthdr, const u_char * packet)</code> 形式完全相同，可以直接当pcap_loop的第二个参数；</p><h1 id="排序思路"><a href="#排序思路" class="headerlink" title="排序思路"></a>排序思路</h1><h2 id="提取特征"><a href="#提取特征" class="headerlink" title="提取特征"></a>提取特征</h2><p><img src="/img/%E5%9C%A8libpcap%E4%B8%8B%E5%AE%9E%E7%8E%B0%E7%A6%BB%E7%BA%BF%E6%B5%81%E9%87%8F%E5%8C%85%E6%8E%92%E5%BA%8F.assets/image-20201019220018746.png"></p><p><img src="/img/%E5%9C%A8libpcap%E4%B8%8B%E5%AE%9E%E7%8E%B0%E7%A6%BB%E7%BA%BF%E6%B5%81%E9%87%8F%E5%8C%85%E6%8E%92%E5%BA%8F.assets/image-20201019220143733.png"></p><p>上面两张图相当关键，是提取出排序思路的要点。整体上可以得出如下的排序原则：</p><ul><li>对于一个流来说， <code>seq</code> 是呈递增趋势的</li><li>存在 <code>ack</code> 包长度为0，对于一个流来说，为0的包接下来的包的 <code>seq</code> 和本次相同，直至传来有长度的包</li><li>如果包为 <code>syn</code> ，对于一个流来说，即使这个包为0，下一个来的包的 <code>seq</code> + 1</li><li>对于一个seesion的包来说，两个之间的 <code>ack</code> 和 <code>seq</code> 存在对应关系，应满足如下的关系：（a、b指一个session中两个不同的流）<ul><li>a的 <code>ack</code> 小于或等于b的 <code>seq</code></li><li>a的 <code>seq</code> 小于b的 <code>ack</code></li></ul></li></ul><h2 id="排序特征总结"><a href="#排序特征总结" class="headerlink" title="排序特征总结"></a>排序特征总结</h2><p>根据上述说明，我们可以得出一些排序时我们需要得出的信息：</p><ul><li><p><code>源IP地址</code> 、 <code>目标IP地址</code></p><p>这两者用于来在一个session中区分出两个不同的流，仅需比较一个就够了。同时我们对session排序需要严格控制插入的规则，应该只允许一个流的插入到另一个流之中，避免出现混乱。</p></li><li><p><code>seq</code> 、<code>next_seq</code></p><p>这两者用于一个流的排序。 <code>next_seq</code> 实际为 <code>seq</code> 值加上包的长度 <code>len</code> ，如果 <code>len</code> 为0正常情况下 <code>seq</code> 和 <code>next_seq</code> 相同，但是在出现包为 <code>syn</code> 时，即使 <code>len</code> 为0， <code>next_seq</code> 也要为 <code>seq</code>  + 1</p></li><li><p><code>ack</code></p><p>用于session的排序中，确定一个流的包在何时插入至另一个流中。有时需要结合 <code>seq</code> 判断</p></li></ul><h2 id="分析流量包"><a href="#分析流量包" class="headerlink" title="分析流量包"></a>分析流量包</h2><p>我们使用libpcap所获得的流量包是裸包，即最原始的包信息，我们需要对获得的包手动进行分析才能得到我们需要的信息。</p><p>调用 <code>pcap_loop</code> 获得的包需要在 <code>callback</code> 函数中进行我们的分析。后两个参数是包的信息关键，原始包信息就在最后一个参数 <code>packet</code> 中，而包的长度则由前一个参数 <code>pkthdr</code> 结构里定义，其结构如下：</p><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_pkthdr</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">ts</span>;</span>    <span class="hljs-comment">/* time stamp */</span>  bpf_u_int32 caplen;   <span class="hljs-comment">/* length of portion present */</span>  bpf_u_int32 len;      <span class="hljs-comment">/* length this packet (off wire) */</span>&#125;;</code></pre><p>在分析过程中我们主要关注 <code>packet</code></p><h3 id="以太网帧头"><a href="#以太网帧头" class="headerlink" title="以太网帧头"></a>以太网帧头</h3><p><code>packet</code> 的第一部分为以太网帧头，排序过程中我们不关心它，不进行解析，只需要知晓它的长度跳过即可。它的长度为 <code>ETH_HLEN</code> ，为14字节</p><h3 id="IP头"><a href="#IP头" class="headerlink" title="IP头"></a>IP头</h3><p>以太网帧头后的部分为IP头，我们通过 <code>netinet/ip.h</code> 中定义好的 <code>iphdr</code> 结构来解析它。结构如下：</p><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> &#123;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__LITTLE_ENDIAN_BITFIELD)</span>__u8ihl:<span class="hljs-number">4</span>,version:<span class="hljs-number">4</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined (__BIG_ENDIAN_BITFIELD)</span>__u8version:<span class="hljs-number">4</span>,  ihl:<span class="hljs-number">4</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">error</span><span class="hljs-meta-string">&quot;Please fix &lt;asm/byteorder.h&gt;&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>__u8tos;__be16tot_len;__be16id;__be16frag_off;__u8ttl;__u8protocol;__sum16check;__be32saddr;__be32daddr;<span class="hljs-comment">/*The options start here. */</span>&#125;;</code></pre><p>通过以下代码计算偏移量，我们就可以获得所需要的IP头结构：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">ip_header</span> =</span> (struct iphdr *)(packet + ETH_HLEN);</code></pre><p>我们关注的IP头信息为 <code>源IP地址</code> 和 <code>目标IP地址</code> ，这两个信息为IP头中的 <code>saddr</code> 和 <code>daddr</code> ，但是直接读取这两者我们不能得到想要的 <code>x.x.x.x</code> 的结构。为了得到想要的内容，我们还需要借助 <code>arpa/inet.h</code> 中定义好的结构 <code>sockaddr_in</code> 。结构如下：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">sa_family_t</span>sin_family;<span class="hljs-comment">//地址族（Address Family）</span><span class="hljs-keyword">uint16_t</span>sin_port;<span class="hljs-comment">//16位TCP/UDP端口号</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span><span class="hljs-title">sin_addr</span>;</span><span class="hljs-comment">//32位IP地址</span><span class="hljs-keyword">char</span>sin_zero[<span class="hljs-number">8</span>];<span class="hljs-comment">//不使用</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span></span><span class="hljs-class">&#123;</span>    In_addr_ts_addr;<span class="hljs-comment">//32位IPv4地址</span>&#125;</code></pre><p>所以，将 <code>saddr</code> 和 <code>daddr</code> 赋给上述结构中的 <code>s_addr</code> ，再调用 <code>inet_ntoa()</code> 函数，就得到了我们需要的两个地址。</p><ul><li><p><code>char *inet_ntoa(struct in_addr in)</code> </p><p>将一个32位网络字节序的二进制IP地址转换成相应的点分十进制的IP地址（返回点分十进制的字符串在静态内存中的指针）。</p><p>所在头文件： <code>arpa/inet.h</code> </p></li></ul><h3 id="TCP头"><a href="#TCP头" class="headerlink" title="TCP头"></a>TCP头</h3><p>IP头后的部分位TCP头，我们通过 <code>netinet/tcp.h</code> 中定义好的 <code>tcphdr</code> 结构解析它。结构如下：</p><pre><code class="hljs C"><span class="hljs-keyword">typedef</span>u_longtcp_seq;<span class="hljs-comment">/*</span><span class="hljs-comment"> * TCP header.</span><span class="hljs-comment"> * Per RFC 793, September, 1981.</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> &#123;</span>u_shortth_sport;<span class="hljs-comment">/* source port */</span>u_shortth_dport;<span class="hljs-comment">/* destination port */</span>tcp_seqth_seq;<span class="hljs-comment">/* sequence number */</span>tcp_seqth_ack;<span class="hljs-comment">/* acknowledgement number */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> BYTE_ORDER == LITTLE_ENDIAN </span>u_charth_x2:<span class="hljs-number">4</span>,<span class="hljs-comment">/* (unused) */</span>th_off:<span class="hljs-number">4</span>;<span class="hljs-comment">/* data offset */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> BYTE_ORDER == BIG_ENDIAN </span>u_charth_off:<span class="hljs-number">4</span>,<span class="hljs-comment">/* data offset */</span>th_x2:<span class="hljs-number">4</span>;<span class="hljs-comment">/* (unused) */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>u_charth_flags;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>TH_FIN0x01</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>TH_SYN0x02</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>TH_RST0x04</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>TH_PUSH0x08</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>TH_ACK0x10</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>TH_URG0x20</span>u_shortth_win;<span class="hljs-comment">/* window */</span>u_shortth_sum;<span class="hljs-comment">/* checksum */</span>u_shortth_urp;<span class="hljs-comment">/* urgent pointer */</span>&#125;;</code></pre><p>通过以下代码计算偏移量，我们就可以获得所需要的TCP头结构：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> *<span class="hljs-title">tcp_header</span> =</span> (struct tcphdr *)(packet + ETH_HLEN + <span class="hljs-keyword">sizeof</span>(struct iphdr));</code></pre><p>我们关注的信息为 <code>seq</code> 、 <code>ack</code> 、 <code>next_seq</code> 。其中， <code>seq</code> 、 <code>ack</code> 是结构中给我们的，通过 <code>th_seq</code> 、 <code>th_ack</code> ，调用 <code>ntohl()</code> 函数，我们就可以得到需要的两个值。</p><ul><li><p><code>uint32_t ntohl(uint32_t netlong)</code> </p><p>将一个无符号长整形数从网络字节顺序转换为主机字节顺序。</p><p>所在头文件： <code>arpa/inet.h</code> </p></li></ul><p><code>next_seq</code> 是接下来的重头戏，因为结构本身并没有给出这个值，需要我们自己去计算得出。按照之前的的分析，这个值是 <code>seq</code> 的值加上包的长度。IP头结构中的 <code>tot_len</code> 可以给我们帮助，只需要用这个长度减去IP头长度和TCP头长度，这两个的长度就需要我们自己获得了。</p><p><img src="/img/%E5%9C%A8libpcap%E4%B8%8B%E5%AE%9E%E7%8E%B0%E7%A6%BB%E7%BA%BF%E6%B5%81%E9%87%8F%E5%8C%85%E6%8E%92%E5%BA%8F.assets/image-20201021111348745.png"></p><p>借助wireshark，我们可以看到IP头的长度在原始数据包中是有所记录的，就在包的第15个字节的后一位，该值*4即为IP头长度</p><p><img src="/img/%E5%9C%A8libpcap%E4%B8%8B%E5%AE%9E%E7%8E%B0%E7%A6%BB%E7%BA%BF%E6%B5%81%E9%87%8F%E5%8C%85%E6%8E%92%E5%BA%8F.assets/image-20201021115924988.png"></p><p>同样的，可以看到TCP头的长度在原始数据包中有记录，在包的第47个字节的前一位，该值*4即为TCP头长度</p><p>通过以下代码计算偏移量，我们就可以获得包的长度了：</p><pre><code class="hljs c">len = ntohs(ip_header-&gt;tot_len) - ((<span class="hljs-keyword">int</span>)packet[<span class="hljs-number">46</span>])/<span class="hljs-number">16</span>*<span class="hljs-number">4</span> - ((<span class="hljs-keyword">int</span>)packet[<span class="hljs-number">14</span>])%<span class="hljs-number">16</span>*<span class="hljs-number">4</span>;</code></pre><p> <code>next_seq</code> 的值即为 <code>seq</code> + <code>len</code></p><h1 id="排序数据结构"><a href="#排序数据结构" class="headerlink" title="排序数据结构"></a>排序数据结构</h1><p>现在我们已经获得了排序所需要的信息，接下来就需要构建一个便于我们排序的结构来进行排序。为了便于我们的插入排序，构建链表是一个不错的选择</p><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packetnode</span>&#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_pkthdr</span> *<span class="hljs-title">pkthdr</span>;</span>u_char *packet;<span class="hljs-keyword">char</span> *srcip;<span class="hljs-keyword">char</span> *dstip;u_long seq;u_long ack;u_long next_seq;&#125;;</code></pre><p>上面的节点结构用来处理数据包，便于后续排序。 <code>pkthdr</code> 和 <code>packet</code> 是原始抓到的数据包，也是我们后续要保存至文件的东西。后面的五个就是在上面分析流量包的环节我们排序所需要的信息，将它保存在这个节点结构中</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packlist</span>&#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packetnode</span> *<span class="hljs-title">data</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packlist</span> *<span class="hljs-title">left</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packlist</span> *<span class="hljs-title">right</span>;</span>&#125;;</code></pre><p>上面的链表结构用来构建链表，有 <code>left</code> 和 <code>right</code> 用来进行查询和插入</p><h1 id="排序流程图"><a href="#排序流程图" class="headerlink" title="排序流程图"></a>排序流程图</h1>]]></content>
    
    
    <categories>
      
      <category>libpcap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>libpcap</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos6.9网络配置</title>
    <link href="/2020/10/08/Centos6.9%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/10/08/Centos6.9%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>Linux初步课程学习中需要搭建一个新的虚拟机，选择了用Centos6.9的minimal版本作为虚拟机版本。不知道是我VMware配置问题还是镜像问题，配置好的虚拟机无法连接网络。</p><p><code>ifconfig</code>可以看见只有一个<code>lo</code>网卡，使用<code>ifconfig -a</code>可以看见有一个<code>eth0</code>网卡未被启用。</p><p>回想起当时新人培训的时候做的小型局域网，记一篇笔记来记录虚拟机的网络配置备忘。</p><h1 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h1><ul><li>进入网卡配置文件目录<code>/etc/sysconfig/network-scripts</code></li><li>找到对应的网卡文件，我的是<code>ifcfg-eth0</code>，进行配置</li></ul><pre><code class="hljs bash"><span class="hljs-comment">#别问我为啥不用vim，centos默认没有vim</span>vi ifcfg-eth0</code></pre><ul><li>重点配置以下内容</li></ul><pre><code class="hljs shell">IPADDR=192.168.229.6   ip地址NETMASK=255.255.255.0  子网掩码GATEWAY=192.168.229.2    网关ONBOOT=yes             随系统自动启动STATIC=true            静态地址BOOTPROTO=static       静态地址（推荐使用这个指定静态地址）</code></pre><ul><li><p>为何使用静态地址？</p><p>我对此的理解还不够，但是从最开始的培训和这次的配置我选择的都是静态地址的选项，使用静态的更为稳定，不需要过多的配置</p></li><li><p>其中，ip地址和网关需要查看VMware的虚拟网络配置器，如下图</p><p><img src="/img/Centos6.9%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/1.png"></p></li></ul><p>  <img src="/img/Centos6.9%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/2.png"></p><ul><li>配置到这里，基本上的网卡配置就完成了</li></ul><h1 id="DNS配置"><a href="#DNS配置" class="headerlink" title="DNS配置"></a>DNS配置</h1><ul><li>完成上述配置后，直接ping百度肯定是ping不同的，因为DNS配置还没有进行</li><li>打开DNS配置文件</li></ul><pre><code class="hljs bash">vi /etc/resolv.conf</code></pre><ul><li>文件里面应该是没有任何内容的，有也没有关系，加入以下内容</li></ul><pre><code class="hljs shell">nameserver 114.114.114.114namesetver 8.8.8.8</code></pre><p><strong>经学长指正，上述方法在重启后DNS会失效，在<code>/etc/sysconfig/network-script/ifcfg-eth0</code>中添加<code>DNS1=X.X.X.X</code>，<code>DNS2=Y.Y.Y.Y</code>等更为合适</strong></p><ul><li>重启网络</li></ul><pre><code class="hljs bash">service network restart</code></pre><ul><li>现在你就可以在这台虚拟机里愉快的使用网络啦！</li></ul><h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><ul><li><p>为啥我要配网络呢？</p><p>因为虚拟机里装好后却不少东西（连vim都没有，差评），配置新的yum源后发现无法更新，进一步发现了没有网络的问题。使用ssh连接不把网卡配好肯定也是无法连接到的。于是就折腾了一下网卡的配置。</p></li><li><p>为啥非要用ssh连接？</p><p>VMware的命令行界面，连复制粘贴的不行，不用ssh在远程终端连接能行吗？！</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
